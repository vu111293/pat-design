//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g 2012-10-21 14:36:45

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using PAT.Common.Classes.SemanticModels.Prob.ExpressionClass;
using PAT.Common.Classes.SemanticModels.Prob.SystemStructure;
using System.Collections.Generic;
using PAT.Common.Classes.Expressions.ExpressionClass;
using System;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class PrismModelParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "A", "AND", "BOOL", "C", "CLOCK", "COLON", "COMMA", "COMMENT", "CONST", "CTMC", "DIVIDE", "DOT", "DOTS", "DOUBLE", "DQUOTE", "DTMC", "E", "ENDINIT", "ENDINVARIANT", "ENDMODULE", "ENDREWARDS", "ENDSYSTEM", "EQ", "F", "FALSE", "FILTER", "FORMULA", "FUNC", "G", "GE", "GLOBAL", "GT", "I", "ID", "IFF", "IMPLIES", "INIT", "INT", "INT_NUM", "INVARIANT", "LABEL", "LBRACE", "LBRACKET", "LE", "LINE_COMMENT", "LPARENTH", "LT", "MAX", "MDP", "MIN", "MINUS", "MODULE", "NE", "NONDETERMINISTIC", "NOT", "OR", "P", "PLUS", "PMAX", "PMIN", "PRIME", "PROB", "PROBABILISTIC", "PTA", "QMARK", "R", "RARROW", "RATE", "RBRACE", "RBRACKET", "RENAME", "REWARDS", "RMAX", "RMIN", "RPARENTH", "S", "SEMICOLON", "STOCHASTIC", "SYSTEM", "TIMES", "TRUE", "U", "W", "WS", "X"
	};
	public const int EOF=-1;
	public const int A=4;
	public const int AND=5;
	public const int BOOL=6;
	public const int C=7;
	public const int CLOCK=8;
	public const int COLON=9;
	public const int COMMA=10;
	public const int COMMENT=11;
	public const int CONST=12;
	public const int CTMC=13;
	public const int DIVIDE=14;
	public const int DOT=15;
	public const int DOTS=16;
	public const int DOUBLE=17;
	public const int DQUOTE=18;
	public const int DTMC=19;
	public const int E=20;
	public const int ENDINIT=21;
	public const int ENDINVARIANT=22;
	public const int ENDMODULE=23;
	public const int ENDREWARDS=24;
	public const int ENDSYSTEM=25;
	public const int EQ=26;
	public const int F=27;
	public const int FALSE=28;
	public const int FILTER=29;
	public const int FORMULA=30;
	public const int FUNC=31;
	public const int G=32;
	public const int GE=33;
	public const int GLOBAL=34;
	public const int GT=35;
	public const int I=36;
	public const int ID=37;
	public const int IFF=38;
	public const int IMPLIES=39;
	public const int INIT=40;
	public const int INT=41;
	public const int INT_NUM=42;
	public const int INVARIANT=43;
	public const int LABEL=44;
	public const int LBRACE=45;
	public const int LBRACKET=46;
	public const int LE=47;
	public const int LINE_COMMENT=48;
	public const int LPARENTH=49;
	public const int LT=50;
	public const int MAX=51;
	public const int MDP=52;
	public const int MIN=53;
	public const int MINUS=54;
	public const int MODULE=55;
	public const int NE=56;
	public const int NONDETERMINISTIC=57;
	public const int NOT=58;
	public const int OR=59;
	public const int P=60;
	public const int PLUS=61;
	public const int PMAX=62;
	public const int PMIN=63;
	public const int PRIME=64;
	public const int PROB=65;
	public const int PROBABILISTIC=66;
	public const int PTA=67;
	public const int QMARK=68;
	public const int R=69;
	public const int RARROW=70;
	public const int RATE=71;
	public const int RBRACE=72;
	public const int RBRACKET=73;
	public const int RENAME=74;
	public const int REWARDS=75;
	public const int RMAX=76;
	public const int RMIN=77;
	public const int RPARENTH=78;
	public const int S=79;
	public const int SEMICOLON=80;
	public const int STOCHASTIC=81;
	public const int SYSTEM=82;
	public const int TIMES=83;
	public const int TRUE=84;
	public const int U=85;
	public const int W=86;
	public const int WS=87;
	public const int X=88;

	public PrismModelParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public PrismModelParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return PrismModelParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g"; } }


		ModelType type = ModelType.MDP;
		FormulaList formulaList = new FormulaList();
		LabelList labelList = new LabelList();
	    	ConstantList constantList = new ConstantList();
		List<VarDeclaration> globalVars = new List<VarDeclaration>();
		List<Module> allModules = new List<Module>();
		List<RewardStruct> rewardStructures = new List<RewardStruct>();
		Expression init = null;
		
		Modules probModules;
		ProbProperties probProperties = new ProbProperties();
				
		List<Expression> argsOfFunc = new List<Expression>();
		
		
		public void parsePrismModel()
		{
			prismmodel();
			probModules = new Modules(type, globalVars, formulaList, labelList, constantList, allModules, rewardStructures, init);
		}
		
		public Modules GetModules()
		{
			return probModules;
		}
		
		public ProbProperties GetProperties()
		{
			return probProperties;
		}
		
		private Module GetModuleByName(string Name)
		{
			foreach (var module in allModules)
			{
				if(module.Name == Name)
				{
					return module;
				}
			}

			throw new Exception("Module with name " + Name + " is not defined!");
		}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_prismmodel();
	partial void LeaveRule_prismmodel();

	// $ANTLR start "prismmodel"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:152:1: prismmodel : ( properties | modules )* ;
	[GrammarRule("prismmodel")]
	private void prismmodel()
	{
		EnterRule_prismmodel();
		EnterRule("prismmodel", 1);
		TraceIn("prismmodel", 1);

			

		try { DebugEnterRule(GrammarFileName, "prismmodel");
		DebugLocation(152, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:156:2: ( ( properties | modules )* )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:156:4: ( properties | modules )*
			{
			DebugLocation(156, 4);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:156:4: ( properties | modules )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=3;
				try { DebugEnterDecision(1, false);
				switch (input.LA(1))
				{
				case A:
				case DQUOTE:
				case E:
				case FALSE:
				case FILTER:
				case FUNC:
				case ID:
				case INT_NUM:
				case LPARENTH:
				case MAX:
				case MIN:
				case MINUS:
				case NOT:
				case P:
				case PMAX:
				case PMIN:
				case R:
				case RMAX:
				case RMIN:
				case S:
				case TRUE:
					{
					alt1 = 1;
					}
					break;
				case LABEL:
					{
					int LA1_23 = input.LA(2);

					if ((EvaluatePredicate(synpred1_PrismModel_fragment)))
					{
						alt1 = 1;
					}
					else if ((EvaluatePredicate(synpred2_PrismModel_fragment)))
					{
						alt1 = 2;
					}


					}
					break;
				case CONST:
					{
					int LA1_24 = input.LA(2);

					if ((EvaluatePredicate(synpred1_PrismModel_fragment)))
					{
						alt1 = 1;
					}
					else if ((EvaluatePredicate(synpred2_PrismModel_fragment)))
					{
						alt1 = 2;
					}


					}
					break;
				case PROB:
				case RATE:
					{
					int LA1_25 = input.LA(2);

					if ((EvaluatePredicate(synpred1_PrismModel_fragment)))
					{
						alt1 = 1;
					}
					else if ((EvaluatePredicate(synpred2_PrismModel_fragment)))
					{
						alt1 = 2;
					}


					}
					break;
				case CTMC:
				case DTMC:
				case FORMULA:
				case GLOBAL:
				case INIT:
				case MDP:
				case MODULE:
				case NONDETERMINISTIC:
				case PROBABILISTIC:
				case REWARDS:
				case STOCHASTIC:
					{
					alt1 = 2;
					}
					break;
				}

				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:156:5: properties
					{
					DebugLocation(156, 5);
					PushFollow(Follow._properties_in_prismmodel1035);
					properties();
					PopFollow();
					if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:156:18: modules
					{
					DebugLocation(156, 18);
					PushFollow(Follow._modules_in_prismmodel1039);
					modules();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("prismmodel", 1);
			LeaveRule("prismmodel", 1);
			LeaveRule_prismmodel();
		}
		DebugLocation(157, 0);
		} finally { DebugExitRule(GrammarFileName, "prismmodel"); }
		return;

	}
	// $ANTLR end "prismmodel"

	partial void EnterRule_properties();
	partial void LeaveRule_properties();

	// $ANTLR start "properties"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:159:1: properties : ( property ( SEMICOLON )* | labelDef[probProperties.labelList] | constantDef[probProperties.constantList] );
	[GrammarRule("properties")]
	private void properties()
	{
		EnterRule_properties();
		EnterRule("properties", 2);
		TraceIn("properties", 2);
		Property property1 = default(Property);


			

		try { DebugEnterRule(GrammarFileName, "properties");
		DebugLocation(159, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:163:2: ( property ( SEMICOLON )* | labelDef[probProperties.labelList] | constantDef[probProperties.constantList] )
			int alt3=3;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case A:
			case DQUOTE:
			case E:
			case FALSE:
			case FILTER:
			case FUNC:
			case ID:
			case INT_NUM:
			case LPARENTH:
			case MAX:
			case MIN:
			case MINUS:
			case NOT:
			case P:
			case PMAX:
			case PMIN:
			case R:
			case RMAX:
			case RMIN:
			case S:
			case TRUE:
				{
				alt3 = 1;
				}
				break;
			case LABEL:
				{
				alt3 = 2;
				}
				break;
			case CONST:
			case PROB:
			case RATE:
				{
				alt3 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:163:4: property ( SEMICOLON )*
				{
				DebugLocation(163, 4);
				PushFollow(Follow._property_in_properties1056);
				property1=property();
				PopFollow();
				if (state.failed) return;
				DebugLocation(163, 13);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:163:13: ( SEMICOLON )*
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_0 = input.LA(1);

					if ((LA2_0==SEMICOLON))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch ( alt2 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:163:14: SEMICOLON
						{
						DebugLocation(163, 14);
						Match(input,SEMICOLON,Follow._SEMICOLON_in_properties1059); if (state.failed) return;

						}
						break;

					default:
						goto loop2;
					}
				}

				loop2:
					;

				} finally { DebugExitSubRule(2); }

				DebugLocation(163, 26);
				if (state.backtracking == 0)
				{
					probProperties.AddProperty(property1); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:164:4: labelDef[probProperties.labelList]
				{
				DebugLocation(164, 4);
				PushFollow(Follow._labelDef_in_properties1068);
				labelDef(probProperties.labelList);
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:165:4: constantDef[probProperties.constantList]
				{
				DebugLocation(165, 4);
				PushFollow(Follow._constantDef_in_properties1074);
				constantDef(probProperties.constantList);
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("properties", 2);
			LeaveRule("properties", 2);
			LeaveRule_properties();
		}
		DebugLocation(166, 0);
		} finally { DebugExitRule(GrammarFileName, "properties"); }
		return;

	}
	// $ANTLR end "properties"

	partial void EnterRule_property();
	partial void LeaveRule_property();

	// $ANTLR start "property"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:169:1: property returns [Property value] : ( DQUOTE ID DQUOTE COLON )? expr= expressionITE ;
	[GrammarRule("property")]
	private Property property()
	{
		EnterRule_property();
		EnterRule("property", 3);
		TraceIn("property", 3);
		Property value = default(Property);


		IToken ID2 = default(IToken);
		Expression expr = default(Expression);


			string name = null;

		try { DebugEnterRule(GrammarFileName, "property");
		DebugLocation(169, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:173:2: ( ( DQUOTE ID DQUOTE COLON )? expr= expressionITE )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:173:4: ( DQUOTE ID DQUOTE COLON )? expr= expressionITE
			{
			DebugLocation(173, 4);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:173:4: ( DQUOTE ID DQUOTE COLON )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==DQUOTE))
			{
				int LA4_1 = input.LA(2);

				if ((LA4_1==ID))
				{
					int LA4_3 = input.LA(3);

					if ((LA4_3==DQUOTE))
					{
						int LA4_4 = input.LA(4);

						if ((LA4_4==COLON))
						{
							alt4 = 1;
						}
					}
				}
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:173:5: DQUOTE ID DQUOTE COLON
				{
				DebugLocation(173, 5);
				Match(input,DQUOTE,Follow._DQUOTE_in_property1096); if (state.failed) return value;
				DebugLocation(173, 12);
				ID2=(IToken)Match(input,ID,Follow._ID_in_property1098); if (state.failed) return value;
				DebugLocation(173, 14);
				if (state.backtracking == 0)
				{
					name = (ID2!=null?ID2.Text:null);
				}
				DebugLocation(173, 33);
				Match(input,DQUOTE,Follow._DQUOTE_in_property1101); if (state.failed) return value;
				DebugLocation(173, 40);
				Match(input,COLON,Follow._COLON_in_property1103); if (state.failed) return value;

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(174, 7);
			PushFollow(Follow._expressionITE_in_property1112);
			expr=expressionITE();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(174, 22);
			if (state.backtracking == 0)
			{
				value = new Property(name, expr);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("property", 3);
			LeaveRule("property", 3);
			LeaveRule_property();
		}
		DebugLocation(175, 0);
		} finally { DebugExitRule(GrammarFileName, "property"); }
		return value;

	}
	// $ANTLR end "property"

	partial void EnterRule_modules();
	partial void LeaveRule_modules();

	// $ANTLR start "modules"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:178:1: modules : ( moduleType | globalDecl | formulaDef[formulaList] | labelDef[labelList] | constantDef[constantList] | renamedModule | module | rewardStruct | initExp );
	[GrammarRule("modules")]
	private void modules()
	{
		EnterRule_modules();
		EnterRule("modules", 4);
		TraceIn("modules", 4);
		ModelType moduleType3 = default(ModelType);
		VarDeclaration globalDecl4 = default(VarDeclaration);
		Module renamedModule5 = default(Module);
		Module module6 = default(Module);
		RewardStruct rewardStruct7 = default(RewardStruct);
		Expression initExp8 = default(Expression);


			
			

		try { DebugEnterRule(GrammarFileName, "modules");
		DebugLocation(178, 1);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:183:2: ( moduleType | globalDecl | formulaDef[formulaList] | labelDef[labelList] | constantDef[constantList] | renamedModule | module | rewardStruct | initExp )
			int alt5=9;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case CTMC:
			case DTMC:
			case MDP:
			case NONDETERMINISTIC:
			case PROBABILISTIC:
			case STOCHASTIC:
				{
				alt5 = 1;
				}
				break;
			case GLOBAL:
				{
				alt5 = 2;
				}
				break;
			case FORMULA:
				{
				alt5 = 3;
				}
				break;
			case LABEL:
				{
				alt5 = 4;
				}
				break;
			case CONST:
			case PROB:
			case RATE:
				{
				alt5 = 5;
				}
				break;
			case MODULE:
				{
				int LA5_6 = input.LA(2);

				if ((LA5_6==ID))
				{
					int LA5_9 = input.LA(3);

					if ((LA5_9==EQ))
					{
						alt5 = 6;
					}
					else if ((LA5_9==ENDMODULE||LA5_9==ID||LA5_9==LBRACKET))
					{
						alt5 = 7;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 5, 9, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 5, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case REWARDS:
				{
				alt5 = 8;
				}
				break;
			case INIT:
				{
				alt5 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:184:4: moduleType
				{
				DebugLocation(184, 4);
				PushFollow(Follow._moduleType_in_modules1133);
				moduleType3=moduleType();
				PopFollow();
				if (state.failed) return;
				DebugLocation(184, 14);
				if (state.backtracking == 0)
				{
					type = moduleType3;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:185:4: globalDecl
				{
				DebugLocation(185, 4);
				PushFollow(Follow._globalDecl_in_modules1139);
				globalDecl4=globalDecl();
				PopFollow();
				if (state.failed) return;
				DebugLocation(185, 14);
				if (state.backtracking == 0)
				{
					globalVars.Add(globalDecl4);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:186:4: formulaDef[formulaList]
				{
				DebugLocation(186, 4);
				PushFollow(Follow._formulaDef_in_modules1145);
				formulaDef(formulaList);
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:187:4: labelDef[labelList]
				{
				DebugLocation(187, 4);
				PushFollow(Follow._labelDef_in_modules1151);
				labelDef(labelList);
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:188:4: constantDef[constantList]
				{
				DebugLocation(188, 4);
				PushFollow(Follow._constantDef_in_modules1157);
				constantDef(constantList);
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:189:4: renamedModule
				{
				DebugLocation(189, 4);
				PushFollow(Follow._renamedModule_in_modules1163);
				renamedModule5=renamedModule();
				PopFollow();
				if (state.failed) return;
				DebugLocation(189, 17);
				if (state.backtracking == 0)
				{
					allModules.Add(renamedModule5);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:190:4: module
				{
				DebugLocation(190, 4);
				PushFollow(Follow._module_in_modules1169);
				module6=module();
				PopFollow();
				if (state.failed) return;
				DebugLocation(190, 10);
				if (state.backtracking == 0)
				{
					allModules.Add(module6);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:191:4: rewardStruct
				{
				DebugLocation(191, 4);
				PushFollow(Follow._rewardStruct_in_modules1175);
				rewardStruct7=rewardStruct();
				PopFollow();
				if (state.failed) return;
				DebugLocation(191, 16);
				if (state.backtracking == 0)
				{
					rewardStructures.Add(rewardStruct7);
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:192:4: initExp
				{
				DebugLocation(192, 4);
				PushFollow(Follow._initExp_in_modules1181);
				initExp8=initExp();
				PopFollow();
				if (state.failed) return;
				DebugLocation(192, 11);
				if (state.backtracking == 0)
				{
					init = initExp8;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("modules", 4);
			LeaveRule("modules", 4);
			LeaveRule_modules();
		}
		DebugLocation(194, 1);
		} finally { DebugExitRule(GrammarFileName, "modules"); }
		return;

	}
	// $ANTLR end "modules"

	partial void EnterRule_moduleType();
	partial void LeaveRule_moduleType();

	// $ANTLR start "moduleType"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:196:1: moduleType returns [ModelType value] : ( ( ( DTMC | PROBABILISTIC ) ) | ( ( MDP | NONDETERMINISTIC ) ) | ( ( CTMC | STOCHASTIC ) ) );
	[GrammarRule("moduleType")]
	private ModelType moduleType()
	{
		EnterRule_moduleType();
		EnterRule("moduleType", 5);
		TraceIn("moduleType", 5);
		ModelType value = default(ModelType);



			

		try { DebugEnterRule(GrammarFileName, "moduleType");
		DebugLocation(196, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:200:2: ( ( ( DTMC | PROBABILISTIC ) ) | ( ( MDP | NONDETERMINISTIC ) ) | ( ( CTMC | STOCHASTIC ) ) )
			int alt6=3;
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case DTMC:
			case PROBABILISTIC:
				{
				alt6 = 1;
				}
				break;
			case MDP:
			case NONDETERMINISTIC:
				{
				alt6 = 2;
				}
				break;
			case CTMC:
			case STOCHASTIC:
				{
				alt6 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:200:4: ( ( DTMC | PROBABILISTIC ) )
				{
				DebugLocation(200, 4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:200:4: ( ( DTMC | PROBABILISTIC ) )
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:200:5: ( DTMC | PROBABILISTIC )
				{
				DebugLocation(200, 5);
				if (input.LA(1)==DTMC||input.LA(1)==PROBABILISTIC)
				{
					input.Consume();
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(200, 27);
				if (state.backtracking == 0)
				{
					value = ModelType.DTMC;
				}

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:201:4: ( ( MDP | NONDETERMINISTIC ) )
				{
				DebugLocation(201, 4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:201:4: ( ( MDP | NONDETERMINISTIC ) )
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:201:5: ( MDP | NONDETERMINISTIC )
				{
				DebugLocation(201, 5);
				if (input.LA(1)==MDP||input.LA(1)==NONDETERMINISTIC)
				{
					input.Consume();
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(201, 29);
				if (state.backtracking == 0)
				{
					value = ModelType.MDP;
				}

				}


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:202:4: ( ( CTMC | STOCHASTIC ) )
				{
				DebugLocation(202, 4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:202:4: ( ( CTMC | STOCHASTIC ) )
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:202:5: ( CTMC | STOCHASTIC )
				{
				DebugLocation(202, 5);
				if (input.LA(1)==CTMC||input.LA(1)==STOCHASTIC)
				{
					input.Consume();
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(202, 24);
				if (state.backtracking == 0)
				{
					value = ModelType.CTMC;
				}

				}


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("moduleType", 5);
			LeaveRule("moduleType", 5);
			LeaveRule_moduleType();
		}
		DebugLocation(203, 0);
		} finally { DebugExitRule(GrammarFileName, "moduleType"); }
		return value;

	}
	// $ANTLR end "moduleType"

	partial void EnterRule_globalDecl();
	partial void LeaveRule_globalDecl();

	// $ANTLR start "globalDecl"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:205:1: globalDecl returns [VarDeclaration value] : GLOBAL declaration ;
	[GrammarRule("globalDecl")]
	private VarDeclaration globalDecl()
	{
		EnterRule_globalDecl();
		EnterRule("globalDecl", 6);
		TraceIn("globalDecl", 6);
		VarDeclaration value = default(VarDeclaration);


		VarDeclaration declaration9 = default(VarDeclaration);


			

		try { DebugEnterRule(GrammarFileName, "globalDecl");
		DebugLocation(205, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:209:2: ( GLOBAL declaration )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:209:4: GLOBAL declaration
			{
			DebugLocation(209, 4);
			Match(input,GLOBAL,Follow._GLOBAL_in_globalDecl1261); if (state.failed) return value;
			DebugLocation(209, 11);
			PushFollow(Follow._declaration_in_globalDecl1263);
			declaration9=declaration();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(209, 22);
			if (state.backtracking == 0)
			{
				value = declaration9;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("globalDecl", 6);
			LeaveRule("globalDecl", 6);
			LeaveRule_globalDecl();
		}
		DebugLocation(210, 0);
		} finally { DebugExitRule(GrammarFileName, "globalDecl"); }
		return value;

	}
	// $ANTLR end "globalDecl"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();

	// $ANTLR start "declaration"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:212:1: declaration returns [VarDeclaration value] : ID COLON varType ( INIT init= expression )? SEMICOLON ;
	[GrammarRule("declaration")]
	private VarDeclaration declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 7);
		TraceIn("declaration", 7);
		VarDeclaration value = default(VarDeclaration);


		IToken ID10 = default(IToken);
		Expression init = default(Expression);
		DeclarationType varType11 = default(DeclarationType);


			

		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(212, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:216:2: ( ID COLON varType ( INIT init= expression )? SEMICOLON )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:216:4: ID COLON varType ( INIT init= expression )? SEMICOLON
			{
			DebugLocation(216, 4);
			ID10=(IToken)Match(input,ID,Follow._ID_in_declaration1283); if (state.failed) return value;
			DebugLocation(216, 7);
			Match(input,COLON,Follow._COLON_in_declaration1285); if (state.failed) return value;
			DebugLocation(216, 13);
			PushFollow(Follow._varType_in_declaration1287);
			varType11=varType();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(216, 21);
			if (state.backtracking == 0)
			{
				value = new VarDeclaration((ID10!=null?ID10.Text:null), varType11);
			}
			DebugLocation(216, 76);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:216:76: ( INIT init= expression )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==INIT))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:216:77: INIT init= expression
				{
				DebugLocation(216, 77);
				Match(input,INIT,Follow._INIT_in_declaration1291); if (state.failed) return value;
				DebugLocation(216, 87);
				PushFollow(Follow._expression_in_declaration1297);
				init=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(216, 99);
				if (state.backtracking == 0)
				{
					value.Init = init;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(216, 130);
			Match(input,SEMICOLON,Follow._SEMICOLON_in_declaration1302); if (state.failed) return value;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("declaration", 7);
			LeaveRule("declaration", 7);
			LeaveRule_declaration();
		}
		DebugLocation(217, 0);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return value;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_varType();
	partial void LeaveRule_varType();

	// $ANTLR start "varType"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:219:1: varType returns [DeclarationType value] : ( LBRACKET low= expression DOTS high= expression RBRACKET | BOOL );
	[GrammarRule("varType")]
	private DeclarationType varType()
	{
		EnterRule_varType();
		EnterRule("varType", 8);
		TraceIn("varType", 8);
		DeclarationType value = default(DeclarationType);


		Expression low = default(Expression);
		Expression high = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "varType");
		DebugLocation(219, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:223:2: ( LBRACKET low= expression DOTS high= expression RBRACKET | BOOL )
			int alt8=2;
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==LBRACKET))
			{
				alt8 = 1;
			}
			else if ((LA8_0==BOOL))
			{
				alt8 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:223:4: LBRACKET low= expression DOTS high= expression RBRACKET
				{
				DebugLocation(223, 4);
				Match(input,LBRACKET,Follow._LBRACKET_in_varType1321); if (state.failed) return value;
				DebugLocation(223, 17);
				PushFollow(Follow._expression_in_varType1327);
				low=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(223, 30);
				Match(input,DOTS,Follow._DOTS_in_varType1329); if (state.failed) return value;
				DebugLocation(223, 40);
				PushFollow(Follow._expression_in_varType1335);
				high=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(223, 53);
				Match(input,RBRACKET,Follow._RBRACKET_in_varType1337); if (state.failed) return value;
				DebugLocation(223, 62);
				if (state.backtracking == 0)
				{
					 value = new DeclarationInt(low, high); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:224:4: BOOL
				{
				DebugLocation(224, 4);
				Match(input,BOOL,Follow._BOOL_in_varType1344); if (state.failed) return value;
				DebugLocation(224, 9);
				if (state.backtracking == 0)
				{
					 value = new DeclarationBool(); 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("varType", 8);
			LeaveRule("varType", 8);
			LeaveRule_varType();
		}
		DebugLocation(225, 0);
		} finally { DebugExitRule(GrammarFileName, "varType"); }
		return value;

	}
	// $ANTLR end "varType"

	partial void EnterRule_formulaDef();
	partial void LeaveRule_formulaDef();

	// $ANTLR start "formulaDef"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:227:1: formulaDef[FormulaList formulaList] : FORMULA ID EQ expr= expression SEMICOLON ;
	[GrammarRule("formulaDef")]
	private void formulaDef(FormulaList formulaList)
	{
		EnterRule_formulaDef();
		EnterRule("formulaDef", 9);
		TraceIn("formulaDef", 9);
		IToken ID12 = default(IToken);
		Expression expr = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "formulaDef");
		DebugLocation(227, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:231:2: ( FORMULA ID EQ expr= expression SEMICOLON )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:231:4: FORMULA ID EQ expr= expression SEMICOLON
			{
			DebugLocation(231, 4);
			Match(input,FORMULA,Follow._FORMULA_in_formulaDef1362); if (state.failed) return;
			DebugLocation(231, 12);
			ID12=(IToken)Match(input,ID,Follow._ID_in_formulaDef1364); if (state.failed) return;
			DebugLocation(231, 15);
			Match(input,EQ,Follow._EQ_in_formulaDef1366); if (state.failed) return;
			DebugLocation(231, 23);
			PushFollow(Follow._expression_in_formulaDef1372);
			expr=expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(231, 36);
			Match(input,SEMICOLON,Follow._SEMICOLON_in_formulaDef1374); if (state.failed) return;
			DebugLocation(231, 45);
			if (state.backtracking == 0)
			{
				formulaList.AddFormula((ID12!=null?ID12.Text:null), expr);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("formulaDef", 9);
			LeaveRule("formulaDef", 9);
			LeaveRule_formulaDef();
		}
		DebugLocation(232, 0);
		} finally { DebugExitRule(GrammarFileName, "formulaDef"); }
		return;

	}
	// $ANTLR end "formulaDef"

	partial void EnterRule_labelDef();
	partial void LeaveRule_labelDef();

	// $ANTLR start "labelDef"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:234:1: labelDef[LabelList labelList] : LABEL DQUOTE ID DQUOTE EQ expr= expression SEMICOLON ;
	[GrammarRule("labelDef")]
	private void labelDef(LabelList labelList)
	{
		EnterRule_labelDef();
		EnterRule("labelDef", 10);
		TraceIn("labelDef", 10);
		IToken ID13 = default(IToken);
		Expression expr = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "labelDef");
		DebugLocation(234, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:238:2: ( LABEL DQUOTE ID DQUOTE EQ expr= expression SEMICOLON )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:238:4: LABEL DQUOTE ID DQUOTE EQ expr= expression SEMICOLON
			{
			DebugLocation(238, 4);
			Match(input,LABEL,Follow._LABEL_in_labelDef1391); if (state.failed) return;
			DebugLocation(238, 10);
			Match(input,DQUOTE,Follow._DQUOTE_in_labelDef1393); if (state.failed) return;
			DebugLocation(238, 17);
			ID13=(IToken)Match(input,ID,Follow._ID_in_labelDef1395); if (state.failed) return;
			DebugLocation(238, 20);
			Match(input,DQUOTE,Follow._DQUOTE_in_labelDef1397); if (state.failed) return;
			DebugLocation(238, 27);
			Match(input,EQ,Follow._EQ_in_labelDef1399); if (state.failed) return;
			DebugLocation(238, 35);
			PushFollow(Follow._expression_in_labelDef1405);
			expr=expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(238, 48);
			Match(input,SEMICOLON,Follow._SEMICOLON_in_labelDef1407); if (state.failed) return;
			DebugLocation(238, 57);
			if (state.backtracking == 0)
			{
				labelList.AddLabel((ID13!=null?ID13.Text:null), expr);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("labelDef", 10);
			LeaveRule("labelDef", 10);
			LeaveRule_labelDef();
		}
		DebugLocation(239, 0);
		} finally { DebugExitRule(GrammarFileName, "labelDef"); }
		return;

	}
	// $ANTLR end "labelDef"

	partial void EnterRule_constantDef();
	partial void LeaveRule_constantDef();

	// $ANTLR start "constantDef"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:241:1: constantDef[ConstantList constantList] : ( ( CONST ( INT | DOUBLE | BOOL )? ) | ( RATE | PROB ) ) ID ( EQ expression )? SEMICOLON ;
	[GrammarRule("constantDef")]
	private void constantDef(ConstantList constantList)
	{
		EnterRule_constantDef();
		EnterRule("constantDef", 11);
		TraceIn("constantDef", 11);
		IToken ID14 = default(IToken);
		Expression expression15 = default(Expression);


			VarType type = VarType.Int;
			string name = string.Empty;
			Expression expr = null;

		try { DebugEnterRule(GrammarFileName, "constantDef");
		DebugLocation(241, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:247:2: ( ( ( CONST ( INT | DOUBLE | BOOL )? ) | ( RATE | PROB ) ) ID ( EQ expression )? SEMICOLON )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:247:4: ( ( CONST ( INT | DOUBLE | BOOL )? ) | ( RATE | PROB ) ) ID ( EQ expression )? SEMICOLON
			{
			DebugLocation(247, 4);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:247:4: ( ( CONST ( INT | DOUBLE | BOOL )? ) | ( RATE | PROB ) )
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==CONST))
			{
				alt10 = 1;
			}
			else if ((LA10_0==PROB||LA10_0==RATE))
			{
				alt10 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:247:5: ( CONST ( INT | DOUBLE | BOOL )? )
				{
				DebugLocation(247, 5);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:247:5: ( CONST ( INT | DOUBLE | BOOL )? )
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:247:6: CONST ( INT | DOUBLE | BOOL )?
				{
				DebugLocation(247, 6);
				Match(input,CONST,Follow._CONST_in_constantDef1426); if (state.failed) return;
				DebugLocation(247, 12);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:247:12: ( INT | DOUBLE | BOOL )?
				int alt9=4;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				switch (input.LA(1))
				{
				case INT:
					{
					alt9 = 1;
					}
					break;
				case DOUBLE:
					{
					alt9 = 2;
					}
					break;
				case BOOL:
					{
					alt9 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:247:13: INT
					{
					DebugLocation(247, 13);
					Match(input,INT,Follow._INT_in_constantDef1429); if (state.failed) return;
					DebugLocation(247, 16);
					if (state.backtracking == 0)
					{
						type = VarType.Int;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:247:40: DOUBLE
					{
					DebugLocation(247, 40);
					Match(input,DOUBLE,Follow._DOUBLE_in_constantDef1434); if (state.failed) return;
					DebugLocation(247, 46);
					if (state.backtracking == 0)
					{
						type = VarType.Double;
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:247:73: BOOL
					{
					DebugLocation(247, 73);
					Match(input,BOOL,Follow._BOOL_in_constantDef1439); if (state.failed) return;
					DebugLocation(247, 77);
					if (state.backtracking == 0)
					{
						type = VarType.Bool;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(9); }


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:248:4: ( RATE | PROB )
				{
				DebugLocation(248, 4);
				if (input.LA(1)==PROB||input.LA(1)==RATE)
				{
					input.Consume();
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(248, 17);
				if (state.backtracking == 0)
				{
					type = VarType.Double;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(249, 2);
			ID14=(IToken)Match(input,ID,Follow._ID_in_constantDef1459); if (state.failed) return;
			DebugLocation(249, 4);
			if (state.backtracking == 0)
			{
				name = (ID14!=null?ID14.Text:null);
			}
			DebugLocation(250, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:250:2: ( EQ expression )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==EQ))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:250:3: EQ expression
				{
				DebugLocation(250, 3);
				Match(input,EQ,Follow._EQ_in_constantDef1464); if (state.failed) return;
				DebugLocation(250, 6);
				PushFollow(Follow._expression_in_constantDef1466);
				expression15=expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(250, 16);
				if (state.backtracking == 0)
				{
					expr = expression15;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(250, 46);
			Match(input,SEMICOLON,Follow._SEMICOLON_in_constantDef1471); if (state.failed) return;
			DebugLocation(251, 2);
			if (state.backtracking == 0)
			{
				constantList.AddConstant(name, expr, type);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("constantDef", 11);
			LeaveRule("constantDef", 11);
			LeaveRule_constantDef();
		}
		DebugLocation(252, 0);
		} finally { DebugExitRule(GrammarFileName, "constantDef"); }
		return;

	}
	// $ANTLR end "constantDef"

	partial void EnterRule_module();
	partial void LeaveRule_module();

	// $ANTLR start "module"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:254:1: module returns [Module value] : MODULE name= ID (var= declaration )* (comm= command )* ENDMODULE ;
	[GrammarRule("module")]
	private Module module()
	{
		EnterRule_module();
		EnterRule("module", 12);
		TraceIn("module", 12);
		Module value = default(Module);


		IToken name = default(IToken);
		VarDeclaration var = default(VarDeclaration);
		Command comm = default(Command);


			List<Command> commands = new List<Command>();
			List<VarDeclaration> localVars = new List<VarDeclaration>();

		try { DebugEnterRule(GrammarFileName, "module");
		DebugLocation(254, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:259:2: ( MODULE name= ID (var= declaration )* (comm= command )* ENDMODULE )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:259:4: MODULE name= ID (var= declaration )* (comm= command )* ENDMODULE
			{
			DebugLocation(259, 4);
			Match(input,MODULE,Follow._MODULE_in_module1493); if (state.failed) return value;
			DebugLocation(259, 16);
			name=(IToken)Match(input,ID,Follow._ID_in_module1499); if (state.failed) return value;
			DebugLocation(259, 20);
			if (state.backtracking == 0)
			{
				value = new Module((name!=null?name.Text:null), commands, localVars);
			}
			DebugLocation(260, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:260:2: (var= declaration )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==ID))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:260:3: var= declaration
					{
					DebugLocation(260, 7);
					PushFollow(Follow._declaration_in_module1509);
					var=declaration();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(260, 20);
					if (state.backtracking == 0)
					{
						localVars.Add(var);
					}

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(261, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:261:2: (comm= command )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==LBRACKET))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:261:3: comm= command
					{
					DebugLocation(261, 8);
					PushFollow(Follow._command_in_module1520);
					comm=command();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(261, 17);
					if (state.backtracking == 0)
					{
						commands.Add(comm);
					}

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(262, 2);
			Match(input,ENDMODULE,Follow._ENDMODULE_in_module1526); if (state.failed) return value;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("module", 12);
			LeaveRule("module", 12);
			LeaveRule_module();
		}
		DebugLocation(263, 0);
		} finally { DebugExitRule(GrammarFileName, "module"); }
		return value;

	}
	// $ANTLR end "module"

	partial void EnterRule_command();
	partial void LeaveRule_command();

	// $ANTLR start "command"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:265:1: command returns [Command value] : LBRACKET ( ID )? RBRACKET expression RARROW updates SEMICOLON ;
	[GrammarRule("command")]
	private Command command()
	{
		EnterRule_command();
		EnterRule("command", 13);
		TraceIn("command", 13);
		Command value = default(Command);


		IToken ID16 = default(IToken);
		Expression expression17 = default(Expression);
		List<Update> updates18 = default(List<Update>);


			string synch = string.Empty;
			Expression guard = null;
			List<Update> updatesInCommand = null;
			

		try { DebugEnterRule(GrammarFileName, "command");
		DebugLocation(265, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:272:2: ( LBRACKET ( ID )? RBRACKET expression RARROW updates SEMICOLON )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:272:4: LBRACKET ( ID )? RBRACKET expression RARROW updates SEMICOLON
			{
			DebugLocation(272, 4);
			Match(input,LBRACKET,Follow._LBRACKET_in_command1545); if (state.failed) return value;
			DebugLocation(272, 13);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:272:13: ( ID )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if ((LA14_0==ID))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:272:15: ID
				{
				DebugLocation(272, 15);
				ID16=(IToken)Match(input,ID,Follow._ID_in_command1549); if (state.failed) return value;
				DebugLocation(272, 18);
				if (state.backtracking == 0)
				{
					synch = (ID16!=null?ID16.Text:null); 
				}

				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(272, 42);
			Match(input,RBRACKET,Follow._RBRACKET_in_command1556); if (state.failed) return value;
			DebugLocation(273, 2);
			PushFollow(Follow._expression_in_command1559);
			expression17=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(273, 12);
			if (state.backtracking == 0)
			{
				guard = expression17;
			}
			DebugLocation(273, 41);
			Match(input,RARROW,Follow._RARROW_in_command1562); if (state.failed) return value;
			DebugLocation(273, 48);
			PushFollow(Follow._updates_in_command1564);
			updates18=updates();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(273, 56);
			if (state.backtracking == 0)
			{
				updatesInCommand = updates18;
			}
			DebugLocation(273, 93);
			Match(input,SEMICOLON,Follow._SEMICOLON_in_command1568); if (state.failed) return value;
			DebugLocation(273, 102);
			if (state.backtracking == 0)
			{
				value = new Command(synch, guard, updatesInCommand);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("command", 13);
			LeaveRule("command", 13);
			LeaveRule_command();
		}
		DebugLocation(274, 0);
		} finally { DebugExitRule(GrammarFileName, "command"); }
		return value;

	}
	// $ANTLR end "command"

	partial void EnterRule_updates();
	partial void LeaveRule_updates();

	// $ANTLR start "updates"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:276:1: updates returns [List<Update> value] : (ass0= assignments |prob1= expression COLON ass1= assignments ( PLUS prob2= expression COLON ass2= assignments )* );
	[GrammarRule("updates")]
	private List<Update> updates()
	{
		EnterRule_updates();
		EnterRule("updates", 14);
		TraceIn("updates", 14);
		List<Update> value = default(List<Update>);


		List<Assignment> ass0 = default(List<Assignment>);
		Expression prob1 = default(Expression);
		List<Assignment> ass1 = default(List<Assignment>);
		Expression prob2 = default(Expression);
		List<Assignment> ass2 = default(List<Assignment>);


			value = new List<Update>();

		try { DebugEnterRule(GrammarFileName, "updates");
		DebugLocation(276, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:280:2: (ass0= assignments |prob1= expression COLON ass1= assignments ( PLUS prob2= expression COLON ass2= assignments )* )
			int alt16=2;
			try { DebugEnterDecision(16, false);
			switch (input.LA(1))
			{
			case LPARENTH:
				{
				int LA16_1 = input.LA(2);

				if ((LA16_1==ID))
				{
					int LA16_4 = input.LA(3);

					if ((LA16_4==PRIME))
					{
						alt16 = 1;
					}
					else if ((LA16_4==AND||LA16_4==DIVIDE||LA16_4==EQ||LA16_4==GE||LA16_4==GT||LA16_4==IMPLIES||LA16_4==LE||(LA16_4>=LPARENTH && LA16_4<=LT)||LA16_4==MINUS||LA16_4==NE||LA16_4==OR||LA16_4==PLUS||(LA16_4>=QMARK && LA16_4<=R)||LA16_4==RPARENTH||LA16_4==TIMES||(LA16_4>=U && LA16_4<=W)))
					{
						alt16 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 16, 4, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA16_1==A||LA16_1==DQUOTE||LA16_1==E||(LA16_1>=F && LA16_1<=FILTER)||(LA16_1>=FUNC && LA16_1<=G)||LA16_1==INT_NUM||LA16_1==LPARENTH||LA16_1==MAX||(LA16_1>=MIN && LA16_1<=MINUS)||LA16_1==NOT||LA16_1==P||(LA16_1>=PMAX && LA16_1<=PMIN)||LA16_1==R||(LA16_1>=RMAX && LA16_1<=RMIN)||LA16_1==S||LA16_1==TRUE||LA16_1==X))
				{
					alt16 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 16, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case TRUE:
				{
				int LA16_2 = input.LA(2);

				if ((LA16_2==SEMICOLON))
				{
					alt16 = 1;
				}
				else if ((LA16_2==AND||LA16_2==COLON||LA16_2==DIVIDE||LA16_2==EQ||LA16_2==GE||LA16_2==GT||LA16_2==IMPLIES||LA16_2==LE||LA16_2==LT||LA16_2==MINUS||LA16_2==NE||LA16_2==OR||LA16_2==PLUS||(LA16_2>=QMARK && LA16_2<=R)||LA16_2==TIMES||(LA16_2>=U && LA16_2<=W)))
				{
					alt16 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 16, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case A:
			case DQUOTE:
			case E:
			case F:
			case FALSE:
			case FILTER:
			case FUNC:
			case G:
			case ID:
			case INT_NUM:
			case MAX:
			case MIN:
			case MINUS:
			case NOT:
			case P:
			case PMAX:
			case PMIN:
			case R:
			case RMAX:
			case RMIN:
			case S:
			case X:
				{
				alt16 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:280:4: ass0= assignments
				{
				DebugLocation(280, 9);
				PushFollow(Follow._assignments_in_updates1592);
				ass0=assignments();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(280, 22);
				if (state.backtracking == 0)
				{
					Update update0 = new Update(ass0, new DoubleConstant(1)); value.Add(update0);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:281:4: prob1= expression COLON ass1= assignments ( PLUS prob2= expression COLON ass2= assignments )*
				{
				DebugLocation(281, 10);
				PushFollow(Follow._expression_in_updates1602);
				prob1=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(281, 23);
				Match(input,COLON,Follow._COLON_in_updates1604); if (state.failed) return value;
				DebugLocation(281, 34);
				PushFollow(Follow._assignments_in_updates1610);
				ass1=assignments();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(281, 47);
				if (state.backtracking == 0)
				{
					Update update1 = new Update(ass1, prob1); value.Add(update1);
				}
				DebugLocation(282, 2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:282:2: ( PLUS prob2= expression COLON ass2= assignments )*
				try { DebugEnterSubRule(15);
				while (true)
				{
					int alt15=2;
					try { DebugEnterDecision(15, false);
					int LA15_0 = input.LA(1);

					if ((LA15_0==PLUS))
					{
						alt15 = 1;
					}


					} finally { DebugExitDecision(15); }
					switch ( alt15 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:282:3: PLUS prob2= expression COLON ass2= assignments
						{
						DebugLocation(282, 3);
						Match(input,PLUS,Follow._PLUS_in_updates1615); if (state.failed) return value;
						DebugLocation(282, 14);
						PushFollow(Follow._expression_in_updates1621);
						prob2=expression();
						PopFollow();
						if (state.failed) return value;
						DebugLocation(282, 27);
						Match(input,COLON,Follow._COLON_in_updates1623); if (state.failed) return value;
						DebugLocation(282, 38);
						PushFollow(Follow._assignments_in_updates1629);
						ass2=assignments();
						PopFollow();
						if (state.failed) return value;
						DebugLocation(282, 51);
						if (state.backtracking == 0)
						{
							Update update2 = new Update(ass2, prob2); value.Add(update2);
						}

						}
						break;

					default:
						goto loop15;
					}
				}

				loop15:
					;

				} finally { DebugExitSubRule(15); }


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("updates", 14);
			LeaveRule("updates", 14);
			LeaveRule_updates();
		}
		DebugLocation(283, 0);
		} finally { DebugExitRule(GrammarFileName, "updates"); }
		return value;

	}
	// $ANTLR end "updates"

	partial void EnterRule_assignments();
	partial void LeaveRule_assignments();

	// $ANTLR start "assignments"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:285:1: assignments returns [List<Assignment> value] : ( (ass1= assignment ( AND ass2= assignment )* ) | TRUE );
	[GrammarRule("assignments")]
	private List<Assignment> assignments()
	{
		EnterRule_assignments();
		EnterRule("assignments", 15);
		TraceIn("assignments", 15);
		List<Assignment> value = default(List<Assignment>);


		Assignment ass1 = default(Assignment);
		Assignment ass2 = default(Assignment);


			value = new List<Assignment>();

		try { DebugEnterRule(GrammarFileName, "assignments");
		DebugLocation(285, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:289:2: ( (ass1= assignment ( AND ass2= assignment )* ) | TRUE )
			int alt18=2;
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==LPARENTH))
			{
				alt18 = 1;
			}
			else if ((LA18_0==TRUE))
			{
				alt18 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 18, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:289:4: (ass1= assignment ( AND ass2= assignment )* )
				{
				DebugLocation(289, 4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:289:4: (ass1= assignment ( AND ass2= assignment )* )
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:289:5: ass1= assignment ( AND ass2= assignment )*
				{
				DebugLocation(289, 10);
				PushFollow(Follow._assignment_in_assignments1656);
				ass1=assignment();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(289, 23);
				if (state.backtracking == 0)
				{
					value.Add(ass1);
				}
				DebugLocation(289, 50);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:289:50: ( AND ass2= assignment )*
				try { DebugEnterSubRule(17);
				while (true)
				{
					int alt17=2;
					try { DebugEnterDecision(17, false);
					int LA17_0 = input.LA(1);

					if ((LA17_0==AND))
					{
						alt17 = 1;
					}


					} finally { DebugExitDecision(17); }
					switch ( alt17 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:289:51: AND ass2= assignment
						{
						DebugLocation(289, 51);
						Match(input,AND,Follow._AND_in_assignments1661); if (state.failed) return value;
						DebugLocation(289, 60);
						PushFollow(Follow._assignment_in_assignments1667);
						ass2=assignment();
						PopFollow();
						if (state.failed) return value;
						DebugLocation(289, 72);
						if (state.backtracking == 0)
						{
							value.Add(ass2);
						}

						}
						break;

					default:
						goto loop17;
					}
				}

				loop17:
					;

				} finally { DebugExitSubRule(17); }


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:290:4: TRUE
				{
				DebugLocation(290, 4);
				Match(input,TRUE,Follow._TRUE_in_assignments1676); if (state.failed) return value;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignments", 15);
			LeaveRule("assignments", 15);
			LeaveRule_assignments();
		}
		DebugLocation(291, 0);
		} finally { DebugExitRule(GrammarFileName, "assignments"); }
		return value;

	}
	// $ANTLR end "assignments"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:293:1: assignment returns [Assignment value] : LPARENTH idPrime EQ expression RPARENTH ;
	[GrammarRule("assignment")]
	private Assignment assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 16);
		TraceIn("assignment", 16);
		Assignment value = default(Assignment);


		string idPrime19 = default(string);
		Expression expression20 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(293, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:297:2: ( LPARENTH idPrime EQ expression RPARENTH )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:297:4: LPARENTH idPrime EQ expression RPARENTH
			{
			DebugLocation(297, 4);
			Match(input,LPARENTH,Follow._LPARENTH_in_assignment1695); if (state.failed) return value;
			DebugLocation(297, 13);
			PushFollow(Follow._idPrime_in_assignment1697);
			idPrime19=idPrime();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(297, 21);
			Match(input,EQ,Follow._EQ_in_assignment1699); if (state.failed) return value;
			DebugLocation(297, 24);
			PushFollow(Follow._expression_in_assignment1701);
			expression20=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(297, 35);
			Match(input,RPARENTH,Follow._RPARENTH_in_assignment1703); if (state.failed) return value;
			DebugLocation(297, 43);
			if (state.backtracking == 0)
			{
				value = new Assignment(idPrime19, expression20);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignment", 16);
			LeaveRule("assignment", 16);
			LeaveRule_assignment();
		}
		DebugLocation(298, 0);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return value;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_idPrime();
	partial void LeaveRule_idPrime();

	// $ANTLR start "idPrime"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:300:1: idPrime returns [string value] : ID PRIME ;
	[GrammarRule("idPrime")]
	private string idPrime()
	{
		EnterRule_idPrime();
		EnterRule("idPrime", 17);
		TraceIn("idPrime", 17);
		string value = default(string);


		IToken ID21 = default(IToken);


			

		try { DebugEnterRule(GrammarFileName, "idPrime");
		DebugLocation(300, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:304:2: ( ID PRIME )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:304:4: ID PRIME
			{
			DebugLocation(304, 4);
			ID21=(IToken)Match(input,ID,Follow._ID_in_idPrime1723); if (state.failed) return value;
			DebugLocation(304, 7);
			Match(input,PRIME,Follow._PRIME_in_idPrime1725); if (state.failed) return value;
			DebugLocation(304, 12);
			if (state.backtracking == 0)
			{
				value = (ID21!=null?ID21.Text:null);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("idPrime", 17);
			LeaveRule("idPrime", 17);
			LeaveRule_idPrime();
		}
		DebugLocation(305, 0);
		} finally { DebugExitRule(GrammarFileName, "idPrime"); }
		return value;

	}
	// $ANTLR end "idPrime"

	partial void EnterRule_renamedModule();
	partial void LeaveRule_renamedModule();

	// $ANTLR start "renamedModule"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:307:1: renamedModule returns [Module value] : MODULE name= ID EQ baseName= ID LBRACKET rename[nameMappings] ( COMMA rename[nameMappings] )* RBRACKET ENDMODULE ;
	[GrammarRule("renamedModule")]
	private Module renamedModule()
	{
		EnterRule_renamedModule();
		EnterRule("renamedModule", 18);
		TraceIn("renamedModule", 18);
		Module value = default(Module);


		IToken name = default(IToken);
		IToken baseName = default(IToken);


			Dictionary<string, string> nameMappings = new Dictionary<string, string>();

		try { DebugEnterRule(GrammarFileName, "renamedModule");
		DebugLocation(307, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:311:2: ( MODULE name= ID EQ baseName= ID LBRACKET rename[nameMappings] ( COMMA rename[nameMappings] )* RBRACKET ENDMODULE )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:311:4: MODULE name= ID EQ baseName= ID LBRACKET rename[nameMappings] ( COMMA rename[nameMappings] )* RBRACKET ENDMODULE
			{
			DebugLocation(311, 4);
			Match(input,MODULE,Follow._MODULE_in_renamedModule1745); if (state.failed) return value;
			DebugLocation(311, 16);
			name=(IToken)Match(input,ID,Follow._ID_in_renamedModule1751); if (state.failed) return value;
			DebugLocation(311, 21);
			Match(input,EQ,Follow._EQ_in_renamedModule1753); if (state.failed) return value;
			DebugLocation(311, 33);
			baseName=(IToken)Match(input,ID,Follow._ID_in_renamedModule1759); if (state.failed) return value;
			DebugLocation(312, 2);
			Match(input,LBRACKET,Follow._LBRACKET_in_renamedModule1762); if (state.failed) return value;
			DebugLocation(312, 11);
			PushFollow(Follow._rename_in_renamedModule1764);
			rename(nameMappings);
			PopFollow();
			if (state.failed) return value;
			DebugLocation(312, 32);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:312:32: ( COMMA rename[nameMappings] )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==COMMA))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:312:33: COMMA rename[nameMappings]
					{
					DebugLocation(312, 33);
					Match(input,COMMA,Follow._COMMA_in_renamedModule1768); if (state.failed) return value;
					DebugLocation(312, 39);
					PushFollow(Follow._rename_in_renamedModule1770);
					rename(nameMappings);
					PopFollow();
					if (state.failed) return value;

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(312, 62);
			Match(input,RBRACKET,Follow._RBRACKET_in_renamedModule1775); if (state.failed) return value;
			DebugLocation(312, 71);
			Match(input,ENDMODULE,Follow._ENDMODULE_in_renamedModule1777); if (state.failed) return value;
			DebugLocation(312, 80);
			if (state.backtracking == 0)
			{
				value = GetModuleByName((baseName!=null?baseName.Text:null)).Rename((name!=null?name.Text:null), nameMappings);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("renamedModule", 18);
			LeaveRule("renamedModule", 18);
			LeaveRule_renamedModule();
		}
		DebugLocation(313, 0);
		} finally { DebugExitRule(GrammarFileName, "renamedModule"); }
		return value;

	}
	// $ANTLR end "renamedModule"

	partial void EnterRule_rename();
	partial void LeaveRule_rename();

	// $ANTLR start "rename"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:315:1: rename[Dictionary<string, string> nameMappings] : id1= ID EQ id2= ID ;
	[GrammarRule("rename")]
	private void rename(Dictionary<string, string> nameMappings)
	{
		EnterRule_rename();
		EnterRule("rename", 19);
		TraceIn("rename", 19);
		IToken id1 = default(IToken);
		IToken id2 = default(IToken);


			

		try { DebugEnterRule(GrammarFileName, "rename");
		DebugLocation(315, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:319:2: (id1= ID EQ id2= ID )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:319:4: id1= ID EQ id2= ID
			{
			DebugLocation(319, 8);
			id1=(IToken)Match(input,ID,Follow._ID_in_rename1798); if (state.failed) return;
			DebugLocation(319, 13);
			Match(input,EQ,Follow._EQ_in_rename1800); if (state.failed) return;
			DebugLocation(319, 20);
			id2=(IToken)Match(input,ID,Follow._ID_in_rename1806); if (state.failed) return;
			DebugLocation(319, 24);
			if (state.backtracking == 0)
			{
				nameMappings.Add((id1!=null?id1.Text:null), (id2!=null?id2.Text:null));
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rename", 19);
			LeaveRule("rename", 19);
			LeaveRule_rename();
		}
		DebugLocation(320, 0);
		} finally { DebugExitRule(GrammarFileName, "rename"); }
		return;

	}
	// $ANTLR end "rename"

	partial void EnterRule_rewardStruct();
	partial void LeaveRule_rewardStruct();

	// $ANTLR start "rewardStruct"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:322:1: rewardStruct returns [RewardStruct value] : REWARDS ( DQUOTE structName= ID DQUOTE )? ( ( LBRACKET (transLabel= ID )? RBRACKET )? guard= expression COLON rewardValue= expression SEMICOLON )* ENDREWARDS ;
	[GrammarRule("rewardStruct")]
	private RewardStruct rewardStruct()
	{
		EnterRule_rewardStruct();
		EnterRule("rewardStruct", 20);
		TraceIn("rewardStruct", 20);
		RewardStruct value = default(RewardStruct);


		IToken structName = default(IToken);
		IToken transLabel = default(IToken);
		Expression guard = default(Expression);
		Expression rewardValue = default(Expression);


			List<RewardItem> rewardItems = new List<RewardItem>();
			string name = string.Empty;
			string s = null;

		try { DebugEnterRule(GrammarFileName, "rewardStruct");
		DebugLocation(322, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:328:2: ( REWARDS ( DQUOTE structName= ID DQUOTE )? ( ( LBRACKET (transLabel= ID )? RBRACKET )? guard= expression COLON rewardValue= expression SEMICOLON )* ENDREWARDS )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:328:4: REWARDS ( DQUOTE structName= ID DQUOTE )? ( ( LBRACKET (transLabel= ID )? RBRACKET )? guard= expression COLON rewardValue= expression SEMICOLON )* ENDREWARDS
			{
			DebugLocation(328, 4);
			Match(input,REWARDS,Follow._REWARDS_in_rewardStruct1826); if (state.failed) return value;
			DebugLocation(328, 12);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:328:12: ( DQUOTE structName= ID DQUOTE )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==DQUOTE))
			{
				int LA20_1 = input.LA(2);

				if ((EvaluatePredicate(synpred36_PrismModel_fragment)))
				{
					alt20 = 1;
				}
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:328:13: DQUOTE structName= ID DQUOTE
				{
				DebugLocation(328, 13);
				Match(input,DQUOTE,Follow._DQUOTE_in_rewardStruct1829); if (state.failed) return value;
				DebugLocation(328, 31);
				structName=(IToken)Match(input,ID,Follow._ID_in_rewardStruct1835); if (state.failed) return value;
				DebugLocation(328, 35);
				if (state.backtracking == 0)
				{
					name = (structName!=null?structName.Text:null);
				}
				DebugLocation(328, 62);
				Match(input,DQUOTE,Follow._DQUOTE_in_rewardStruct1838); if (state.failed) return value;

				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(329, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:329:2: ( ( LBRACKET (transLabel= ID )? RBRACKET )? guard= expression COLON rewardValue= expression SEMICOLON )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==A||LA23_0==DQUOTE||LA23_0==E||(LA23_0>=F && LA23_0<=FILTER)||(LA23_0>=FUNC && LA23_0<=G)||LA23_0==ID||LA23_0==INT_NUM||LA23_0==LBRACKET||LA23_0==LPARENTH||LA23_0==MAX||(LA23_0>=MIN && LA23_0<=MINUS)||LA23_0==NOT||LA23_0==P||(LA23_0>=PMAX && LA23_0<=PMIN)||LA23_0==R||(LA23_0>=RMAX && LA23_0<=RMIN)||LA23_0==S||LA23_0==TRUE||LA23_0==X))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:329:3: ( LBRACKET (transLabel= ID )? RBRACKET )? guard= expression COLON rewardValue= expression SEMICOLON
					{
					DebugLocation(329, 3);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:329:3: ( LBRACKET (transLabel= ID )? RBRACKET )?
					int alt22=2;
					try { DebugEnterSubRule(22);
					try { DebugEnterDecision(22, false);
					int LA22_0 = input.LA(1);

					if ((LA22_0==LBRACKET))
					{
						alt22 = 1;
					}
					} finally { DebugExitDecision(22); }
					switch (alt22)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:329:4: LBRACKET (transLabel= ID )? RBRACKET
						{
						DebugLocation(329, 4);
						Match(input,LBRACKET,Follow._LBRACKET_in_rewardStruct1845); if (state.failed) return value;
						DebugLocation(329, 12);
						if (state.backtracking == 0)
						{
							s = string.Empty;
						}
						DebugLocation(329, 32);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:329:32: (transLabel= ID )?
						int alt21=2;
						try { DebugEnterSubRule(21);
						try { DebugEnterDecision(21, false);
						int LA21_0 = input.LA(1);

						if ((LA21_0==ID))
						{
							alt21 = 1;
						}
						} finally { DebugExitDecision(21); }
						switch (alt21)
						{
						case 1:
							DebugEnterAlt(1);
							// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:329:33: transLabel= ID
							{
							DebugLocation(329, 44);
							transLabel=(IToken)Match(input,ID,Follow._ID_in_rewardStruct1853); if (state.failed) return value;
							DebugLocation(329, 48);
							if (state.backtracking == 0)
							{
								s = (transLabel!=null?transLabel.Text:null);
							}

							}
							break;

						}
						} finally { DebugExitSubRule(21); }

						DebugLocation(329, 74);
						Match(input,RBRACKET,Follow._RBRACKET_in_rewardStruct1858); if (state.failed) return value;

						}
						break;

					}
					} finally { DebugExitSubRule(22); }

					DebugLocation(330, 8);
					PushFollow(Follow._expression_in_rewardStruct1867);
					guard=expression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(330, 21);
					Match(input,COLON,Follow._COLON_in_rewardStruct1869); if (state.failed) return value;
					DebugLocation(330, 39);
					PushFollow(Follow._expression_in_rewardStruct1875);
					rewardValue=expression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(330, 52);
					Match(input,SEMICOLON,Follow._SEMICOLON_in_rewardStruct1877); if (state.failed) return value;
					DebugLocation(330, 61);
					if (state.backtracking == 0)
					{
						rewardItems.Add(new RewardItem(s, guard, rewardValue));
					}

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }

			DebugLocation(330, 135);
			Match(input,ENDREWARDS,Follow._ENDREWARDS_in_rewardStruct1882); if (state.failed) return value;
			DebugLocation(331, 2);
			if (state.backtracking == 0)
			{
				value = new RewardStruct(name, rewardItems);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewardStruct", 20);
			LeaveRule("rewardStruct", 20);
			LeaveRule_rewardStruct();
		}
		DebugLocation(332, 0);
		} finally { DebugExitRule(GrammarFileName, "rewardStruct"); }
		return value;

	}
	// $ANTLR end "rewardStruct"

	partial void EnterRule_initExp();
	partial void LeaveRule_initExp();

	// $ANTLR start "initExp"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:334:1: initExp returns [Expression value] : INIT expression ENDINIT ;
	[GrammarRule("initExp")]
	private Expression initExp()
	{
		EnterRule_initExp();
		EnterRule("initExp", 21);
		TraceIn("initExp", 21);
		Expression value = default(Expression);


		Expression expression22 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "initExp");
		DebugLocation(334, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:338:2: ( INIT expression ENDINIT )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:338:4: INIT expression ENDINIT
			{
			DebugLocation(338, 4);
			Match(input,INIT,Follow._INIT_in_initExp1904); if (state.failed) return value;
			DebugLocation(338, 9);
			PushFollow(Follow._expression_in_initExp1906);
			expression22=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(338, 19);
			if (state.backtracking == 0)
			{
				value = expression22;
			}
			DebugLocation(338, 49);
			Match(input,ENDINIT,Follow._ENDINIT_in_initExp1909); if (state.failed) return value;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("initExp", 21);
			LeaveRule("initExp", 21);
			LeaveRule_initExp();
		}
		DebugLocation(339, 0);
		} finally { DebugExitRule(GrammarFileName, "initExp"); }
		return value;

	}
	// $ANTLR end "initExp"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:340:1: expression returns [Expression value] : expressionTemporalBinary ;
	[GrammarRule("expression")]
	private Expression expression()
	{
		EnterRule_expression();
		EnterRule("expression", 22);
		TraceIn("expression", 22);
		Expression value = default(Expression);


		Expression expressionTemporalBinary23 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(340, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:344:2: ( expressionTemporalBinary )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:344:4: expressionTemporalBinary
			{
			DebugLocation(344, 4);
			PushFollow(Follow._expressionTemporalBinary_in_expression1927);
			expressionTemporalBinary23=expressionTemporalBinary();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(344, 28);
			if (state.backtracking == 0)
			{
				value = expressionTemporalBinary23;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 22);
			LeaveRule("expression", 22);
			LeaveRule_expression();
		}
		DebugLocation(345, 0);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return value;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expressionTemporalBinary();
	partial void LeaveRule_expressionTemporalBinary();

	// $ANTLR start "expressionTemporalBinary"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:347:1: expressionTemporalBinary returns [Expression value] : opr1= expressionTemporalUnary ( ( U | W | R ) ( timeBound )? opr2= expressionTemporalUnary )? ;
	[GrammarRule("expressionTemporalBinary")]
	private Expression expressionTemporalBinary()
	{
		EnterRule_expressionTemporalBinary();
		EnterRule("expressionTemporalBinary", 23);
		TraceIn("expressionTemporalBinary", 23);
		Expression value = default(Expression);


		Expression opr1 = default(Expression);
		Expression opr2 = default(Expression);
		TimeBound timeBound24 = default(TimeBound);


			Temporal temp = new Temporal();

		try { DebugEnterRule(GrammarFileName, "expressionTemporalBinary");
		DebugLocation(347, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:351:2: (opr1= expressionTemporalUnary ( ( U | W | R ) ( timeBound )? opr2= expressionTemporalUnary )? )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:351:4: opr1= expressionTemporalUnary ( ( U | W | R ) ( timeBound )? opr2= expressionTemporalUnary )?
			{
			DebugLocation(351, 9);
			PushFollow(Follow._expressionTemporalUnary_in_expressionTemporalBinary1951);
			opr1=expressionTemporalUnary();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(351, 34);
			if (state.backtracking == 0)
			{
				value = opr1;
			}
			DebugLocation(352, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:352:2: ( ( U | W | R ) ( timeBound )? opr2= expressionTemporalUnary )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if (((LA26_0>=U && LA26_0<=W)))
			{
				alt26 = 1;
			}
			else if ((LA26_0==R))
			{
				int LA26_3 = input.LA(2);

				if ((EvaluatePredicate(synpred43_PrismModel_fragment)))
				{
					alt26 = 1;
				}
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:353:3: ( U | W | R ) ( timeBound )? opr2= expressionTemporalUnary
				{
				DebugLocation(353, 3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:353:3: ( U | W | R )
				int alt24=3;
				try { DebugEnterSubRule(24);
				try { DebugEnterDecision(24, false);
				switch (input.LA(1))
				{
				case U:
					{
					alt24 = 1;
					}
					break;
				case W:
					{
					alt24 = 2;
					}
					break;
				case R:
					{
					alt24 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:353:5: U
					{
					DebugLocation(353, 5);
					Match(input,U,Follow._U_in_expressionTemporalBinary1961); if (state.failed) return value;
					DebugLocation(353, 6);
					if (state.backtracking == 0)
					{
						temp.op = TemporalOpt.Until;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:354:5: W
					{
					DebugLocation(354, 5);
					Match(input,W,Follow._W_in_expressionTemporalBinary1968); if (state.failed) return value;
					DebugLocation(354, 6);
					if (state.backtracking == 0)
					{
						temp.op = TemporalOpt.WeakUntil;
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:355:5: R
					{
					DebugLocation(355, 5);
					Match(input,R,Follow._R_in_expressionTemporalBinary1975); if (state.failed) return value;
					DebugLocation(355, 6);
					if (state.backtracking == 0)
					{
						temp.op = TemporalOpt.Release;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(24); }

				DebugLocation(357, 3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:357:3: ( timeBound )?
				int alt25=2;
				try { DebugEnterSubRule(25);
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==GE||LA25_0==GT||(LA25_0>=LBRACKET && LA25_0<=LE)||LA25_0==LT))
				{
					alt25 = 1;
				}
				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:357:4: timeBound
					{
					DebugLocation(357, 4);
					PushFollow(Follow._timeBound_in_expressionTemporalBinary1985);
					timeBound24=timeBound();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(357, 13);
					if (state.backtracking == 0)
					{
						temp.SetTimeBound(timeBound24);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(25); }

				DebugLocation(358, 8);
				PushFollow(Follow._expressionTemporalUnary_in_expressionTemporalBinary1996);
				opr2=expressionTemporalUnary();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(358, 33);
				if (state.backtracking == 0)
				{
					temp.operand2 = opr2; temp.operand1 = value; value = temp;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(26); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionTemporalBinary", 23);
			LeaveRule("expressionTemporalBinary", 23);
			LeaveRule_expressionTemporalBinary();
		}
		DebugLocation(360, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionTemporalBinary"); }
		return value;

	}
	// $ANTLR end "expressionTemporalBinary"

	partial void EnterRule_expressionTemporalUnary();
	partial void LeaveRule_expressionTemporalUnary();

	// $ANTLR start "expressionTemporalUnary"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:363:1: expressionTemporalUnary returns [Expression value] : ( ( X | F | G ) ( timeBound )? opr2= expressionTemporalUnary | expressionITE );
	[GrammarRule("expressionTemporalUnary")]
	private Expression expressionTemporalUnary()
	{
		EnterRule_expressionTemporalUnary();
		EnterRule("expressionTemporalUnary", 24);
		TraceIn("expressionTemporalUnary", 24);
		Expression value = default(Expression);


		Expression opr2 = default(Expression);
		TimeBound timeBound25 = default(TimeBound);
		Expression expressionITE26 = default(Expression);


			Temporal temp = new Temporal();

		try { DebugEnterRule(GrammarFileName, "expressionTemporalUnary");
		DebugLocation(363, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:367:2: ( ( X | F | G ) ( timeBound )? opr2= expressionTemporalUnary | expressionITE )
			int alt29=2;
			try { DebugEnterDecision(29, false);
			int LA29_0 = input.LA(1);

			if ((LA29_0==F||LA29_0==G||LA29_0==X))
			{
				alt29 = 1;
			}
			else if ((LA29_0==A||LA29_0==DQUOTE||LA29_0==E||(LA29_0>=FALSE && LA29_0<=FILTER)||LA29_0==FUNC||LA29_0==ID||LA29_0==INT_NUM||LA29_0==LPARENTH||LA29_0==MAX||(LA29_0>=MIN && LA29_0<=MINUS)||LA29_0==NOT||LA29_0==P||(LA29_0>=PMAX && LA29_0<=PMIN)||LA29_0==R||(LA29_0>=RMAX && LA29_0<=RMIN)||LA29_0==S||LA29_0==TRUE))
			{
				alt29 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 29, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:367:3: ( X | F | G ) ( timeBound )? opr2= expressionTemporalUnary
				{
				DebugLocation(367, 3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:367:3: ( X | F | G )
				int alt27=3;
				try { DebugEnterSubRule(27);
				try { DebugEnterDecision(27, false);
				switch (input.LA(1))
				{
				case X:
					{
					alt27 = 1;
					}
					break;
				case F:
					{
					alt27 = 2;
					}
					break;
				case G:
					{
					alt27 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:368:3: X
					{
					DebugLocation(368, 3);
					Match(input,X,Follow._X_in_expressionTemporalUnary2024); if (state.failed) return value;
					DebugLocation(368, 4);
					if (state.backtracking == 0)
					{
						temp.op = TemporalOpt.Next;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:369:4: F
					{
					DebugLocation(369, 4);
					Match(input,F,Follow._F_in_expressionTemporalUnary2030); if (state.failed) return value;
					DebugLocation(369, 5);
					if (state.backtracking == 0)
					{
						temp.op = TemporalOpt.Future;
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:370:4: G
					{
					DebugLocation(370, 4);
					Match(input,G,Follow._G_in_expressionTemporalUnary2036); if (state.failed) return value;
					DebugLocation(370, 5);
					if (state.backtracking == 0)
					{
						temp.op = TemporalOpt.Global;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(27); }

				DebugLocation(372, 2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:372:2: ( timeBound )?
				int alt28=2;
				try { DebugEnterSubRule(28);
				try { DebugEnterDecision(28, false);
				int LA28_0 = input.LA(1);

				if ((LA28_0==GE||LA28_0==GT||(LA28_0>=LBRACKET && LA28_0<=LE)||LA28_0==LT))
				{
					alt28 = 1;
				}
				} finally { DebugExitDecision(28); }
				switch (alt28)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:372:3: timeBound
					{
					DebugLocation(372, 3);
					PushFollow(Follow._timeBound_in_expressionTemporalUnary2044);
					timeBound25=timeBound();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(372, 12);
					if (state.backtracking == 0)
					{
						temp.SetTimeBound(timeBound25);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(28); }

				DebugLocation(373, 7);
				PushFollow(Follow._expressionTemporalUnary_in_expressionTemporalUnary2054);
				opr2=expressionTemporalUnary();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(373, 32);
				if (state.backtracking == 0)
				{
					temp.operand2 = opr2; value = temp;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:374:3: expressionITE
				{
				DebugLocation(374, 3);
				PushFollow(Follow._expressionITE_in_expressionTemporalUnary2059);
				expressionITE26=expressionITE();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(374, 16);
				if (state.backtracking == 0)
				{
					value = expressionITE26;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionTemporalUnary", 24);
			LeaveRule("expressionTemporalUnary", 24);
			LeaveRule_expressionTemporalUnary();
		}
		DebugLocation(376, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionTemporalUnary"); }
		return value;

	}
	// $ANTLR end "expressionTemporalUnary"

	partial void EnterRule_timeBound();
	partial void LeaveRule_timeBound();

	// $ANTLR start "timeBound"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:379:1: timeBound returns [TimeBound value] : ( LE (var1= ID |exp1= expression ) | LT (var2= ID |exp2= expression ) | GE (var3= ID |exp3= expression ) | GT (var4= ID |exp4= expression ) | LBRACKET lowExp= expression COMMA highExp= expression RBRACKET );
	[GrammarRule("timeBound")]
	private TimeBound timeBound()
	{
		EnterRule_timeBound();
		EnterRule("timeBound", 25);
		TraceIn("timeBound", 25);
		TimeBound value = default(TimeBound);


		IToken var1 = default(IToken);
		IToken var2 = default(IToken);
		IToken var3 = default(IToken);
		IToken var4 = default(IToken);
		Expression exp1 = default(Expression);
		Expression exp2 = default(Expression);
		Expression exp3 = default(Expression);
		Expression exp4 = default(Expression);
		Expression lowExp = default(Expression);
		Expression highExp = default(Expression);


			value = new TimeBound();

		try { DebugEnterRule(GrammarFileName, "timeBound");
		DebugLocation(379, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:383:2: ( LE (var1= ID |exp1= expression ) | LT (var2= ID |exp2= expression ) | GE (var3= ID |exp3= expression ) | GT (var4= ID |exp4= expression ) | LBRACKET lowExp= expression COMMA highExp= expression RBRACKET )
			int alt34=5;
			try { DebugEnterDecision(34, false);
			switch (input.LA(1))
			{
			case LE:
				{
				alt34 = 1;
				}
				break;
			case LT:
				{
				alt34 = 2;
				}
				break;
			case GE:
				{
				alt34 = 3;
				}
				break;
			case GT:
				{
				alt34 = 4;
				}
				break;
			case LBRACKET:
				{
				alt34 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 34, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:383:4: LE (var1= ID |exp1= expression )
				{
				DebugLocation(383, 4);
				Match(input,LE,Follow._LE_in_timeBound2082); if (state.failed) return value;
				DebugLocation(383, 7);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:383:7: (var1= ID |exp1= expression )
				int alt30=2;
				try { DebugEnterSubRule(30);
				try { DebugEnterDecision(30, false);
				int LA30_0 = input.LA(1);

				if ((LA30_0==ID))
				{
					int LA30_1 = input.LA(2);

					if ((EvaluatePredicate(synpred48_PrismModel_fragment)))
					{
						alt30 = 1;
					}
					else if ((true))
					{
						alt30 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 30, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA30_0==A||LA30_0==DQUOTE||LA30_0==E||(LA30_0>=F && LA30_0<=FILTER)||(LA30_0>=FUNC && LA30_0<=G)||LA30_0==INT_NUM||LA30_0==LPARENTH||LA30_0==MAX||(LA30_0>=MIN && LA30_0<=MINUS)||LA30_0==NOT||LA30_0==P||(LA30_0>=PMAX && LA30_0<=PMIN)||LA30_0==R||(LA30_0>=RMAX && LA30_0<=RMIN)||LA30_0==S||LA30_0==TRUE||LA30_0==X))
				{
					alt30 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(30); }
				switch (alt30)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:383:8: var1= ID
					{
					DebugLocation(383, 13);
					var1=(IToken)Match(input,ID,Follow._ID_in_timeBound2089); if (state.failed) return value;
					DebugLocation(383, 17);
					if (state.backtracking == 0)
					{
						value.uBound = new Variable((var1!=null?var1.Text:null));
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:383:62: exp1= expression
					{
					DebugLocation(383, 67);
					PushFollow(Follow._expression_in_timeBound2098);
					exp1=expression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(383, 79);
					if (state.backtracking == 0)
					{
						value.uBound = exp1;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(30); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:384:4: LT (var2= ID |exp2= expression )
				{
				DebugLocation(384, 4);
				Match(input,LT,Follow._LT_in_timeBound2105); if (state.failed) return value;
				DebugLocation(384, 7);
				if (state.backtracking == 0)
				{
					value.uBoundStrict=true;
				}
				DebugLocation(384, 34);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:384:34: (var2= ID |exp2= expression )
				int alt31=2;
				try { DebugEnterSubRule(31);
				try { DebugEnterDecision(31, false);
				int LA31_0 = input.LA(1);

				if ((LA31_0==ID))
				{
					int LA31_1 = input.LA(2);

					if ((EvaluatePredicate(synpred50_PrismModel_fragment)))
					{
						alt31 = 1;
					}
					else if ((true))
					{
						alt31 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 31, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA31_0==A||LA31_0==DQUOTE||LA31_0==E||(LA31_0>=F && LA31_0<=FILTER)||(LA31_0>=FUNC && LA31_0<=G)||LA31_0==INT_NUM||LA31_0==LPARENTH||LA31_0==MAX||(LA31_0>=MIN && LA31_0<=MINUS)||LA31_0==NOT||LA31_0==P||(LA31_0>=PMAX && LA31_0<=PMIN)||LA31_0==R||(LA31_0>=RMAX && LA31_0<=RMIN)||LA31_0==S||LA31_0==TRUE||LA31_0==X))
				{
					alt31 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 31, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:384:35: var2= ID
					{
					DebugLocation(384, 40);
					var2=(IToken)Match(input,ID,Follow._ID_in_timeBound2114); if (state.failed) return value;
					DebugLocation(384, 44);
					if (state.backtracking == 0)
					{
						value.uBound = new Variable((var2!=null?var2.Text:null));
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:384:89: exp2= expression
					{
					DebugLocation(384, 94);
					PushFollow(Follow._expression_in_timeBound2123);
					exp2=expression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(384, 106);
					if (state.backtracking == 0)
					{
						value.uBound = exp2;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(31); }


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:385:4: GE (var3= ID |exp3= expression )
				{
				DebugLocation(385, 4);
				Match(input,GE,Follow._GE_in_timeBound2130); if (state.failed) return value;
				DebugLocation(385, 7);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:385:7: (var3= ID |exp3= expression )
				int alt32=2;
				try { DebugEnterSubRule(32);
				try { DebugEnterDecision(32, false);
				int LA32_0 = input.LA(1);

				if ((LA32_0==ID))
				{
					int LA32_1 = input.LA(2);

					if ((EvaluatePredicate(synpred52_PrismModel_fragment)))
					{
						alt32 = 1;
					}
					else if ((true))
					{
						alt32 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 32, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA32_0==A||LA32_0==DQUOTE||LA32_0==E||(LA32_0>=F && LA32_0<=FILTER)||(LA32_0>=FUNC && LA32_0<=G)||LA32_0==INT_NUM||LA32_0==LPARENTH||LA32_0==MAX||(LA32_0>=MIN && LA32_0<=MINUS)||LA32_0==NOT||LA32_0==P||(LA32_0>=PMAX && LA32_0<=PMIN)||LA32_0==R||(LA32_0>=RMAX && LA32_0<=RMIN)||LA32_0==S||LA32_0==TRUE||LA32_0==X))
				{
					alt32 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 32, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(32); }
				switch (alt32)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:385:8: var3= ID
					{
					DebugLocation(385, 13);
					var3=(IToken)Match(input,ID,Follow._ID_in_timeBound2137); if (state.failed) return value;
					DebugLocation(385, 17);
					if (state.backtracking == 0)
					{
						value.lBound = new Variable((var3!=null?var3.Text:null));
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:385:62: exp3= expression
					{
					DebugLocation(385, 67);
					PushFollow(Follow._expression_in_timeBound2146);
					exp3=expression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(385, 79);
					if (state.backtracking == 0)
					{
						value.lBound = exp3;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(32); }


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:386:4: GT (var4= ID |exp4= expression )
				{
				DebugLocation(386, 4);
				Match(input,GT,Follow._GT_in_timeBound2153); if (state.failed) return value;
				DebugLocation(386, 7);
				if (state.backtracking == 0)
				{
					value.lBoundStrict=true;
				}
				DebugLocation(386, 34);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:386:34: (var4= ID |exp4= expression )
				int alt33=2;
				try { DebugEnterSubRule(33);
				try { DebugEnterDecision(33, false);
				int LA33_0 = input.LA(1);

				if ((LA33_0==ID))
				{
					int LA33_1 = input.LA(2);

					if ((EvaluatePredicate(synpred54_PrismModel_fragment)))
					{
						alt33 = 1;
					}
					else if ((true))
					{
						alt33 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 33, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA33_0==A||LA33_0==DQUOTE||LA33_0==E||(LA33_0>=F && LA33_0<=FILTER)||(LA33_0>=FUNC && LA33_0<=G)||LA33_0==INT_NUM||LA33_0==LPARENTH||LA33_0==MAX||(LA33_0>=MIN && LA33_0<=MINUS)||LA33_0==NOT||LA33_0==P||(LA33_0>=PMAX && LA33_0<=PMIN)||LA33_0==R||(LA33_0>=RMAX && LA33_0<=RMIN)||LA33_0==S||LA33_0==TRUE||LA33_0==X))
				{
					alt33 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 33, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(33); }
				switch (alt33)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:386:35: var4= ID
					{
					DebugLocation(386, 40);
					var4=(IToken)Match(input,ID,Follow._ID_in_timeBound2162); if (state.failed) return value;
					DebugLocation(386, 44);
					if (state.backtracking == 0)
					{
						value.lBound = new Variable((var4!=null?var4.Text:null));
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:386:89: exp4= expression
					{
					DebugLocation(386, 94);
					PushFollow(Follow._expression_in_timeBound2171);
					exp4=expression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(386, 106);
					if (state.backtracking == 0)
					{
						value.lBound = exp4;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(33); }


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:387:4: LBRACKET lowExp= expression COMMA highExp= expression RBRACKET
				{
				DebugLocation(387, 4);
				Match(input,LBRACKET,Follow._LBRACKET_in_timeBound2178); if (state.failed) return value;
				DebugLocation(387, 20);
				PushFollow(Follow._expression_in_timeBound2184);
				lowExp=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(387, 32);
				if (state.backtracking == 0)
				{
					value.lBound = lowExp;
				}
				DebugLocation(387, 64);
				Match(input,COMMA,Follow._COMMA_in_timeBound2187); if (state.failed) return value;
				DebugLocation(387, 78);
				PushFollow(Follow._expression_in_timeBound2193);
				highExp=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(387, 90);
				if (state.backtracking == 0)
				{
					value.uBound = highExp;
				}
				DebugLocation(387, 123);
				Match(input,RBRACKET,Follow._RBRACKET_in_timeBound2196); if (state.failed) return value;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("timeBound", 25);
			LeaveRule("timeBound", 25);
			LeaveRule_timeBound();
		}
		DebugLocation(389, 0);
		} finally { DebugExitRule(GrammarFileName, "timeBound"); }
		return value;

	}
	// $ANTLR end "timeBound"

	partial void EnterRule_expressionITE();
	partial void LeaveRule_expressionITE();

	// $ANTLR start "expressionITE"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:392:1: expressionITE returns [Expression value] : cond= expressionImplies ( QMARK ifPart= expressionImplies COLON elsePart= expressionITE )? ;
	[GrammarRule("expressionITE")]
	private Expression expressionITE()
	{
		EnterRule_expressionITE();
		EnterRule("expressionITE", 26);
		TraceIn("expressionITE", 26);
		Expression value = default(Expression);


		Expression cond = default(Expression);
		Expression ifPart = default(Expression);
		Expression elsePart = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expressionITE");
		DebugLocation(392, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:396:2: (cond= expressionImplies ( QMARK ifPart= expressionImplies COLON elsePart= expressionITE )? )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:396:4: cond= expressionImplies ( QMARK ifPart= expressionImplies COLON elsePart= expressionITE )?
			{
			DebugLocation(396, 9);
			PushFollow(Follow._expressionImplies_in_expressionITE2222);
			cond=expressionImplies();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(396, 28);
			if (state.backtracking == 0)
			{
				value = cond;
			}
			DebugLocation(397, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:397:2: ( QMARK ifPart= expressionImplies COLON elsePart= expressionITE )?
			int alt35=2;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, false);
			int LA35_0 = input.LA(1);

			if ((LA35_0==QMARK))
			{
				alt35 = 1;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:397:3: QMARK ifPart= expressionImplies COLON elsePart= expressionITE
				{
				DebugLocation(397, 3);
				Match(input,QMARK,Follow._QMARK_in_expressionITE2227); if (state.failed) return value;
				DebugLocation(397, 16);
				PushFollow(Follow._expressionImplies_in_expressionITE2233);
				ifPart=expressionImplies();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(397, 36);
				Match(input,COLON,Follow._COLON_in_expressionITE2235); if (state.failed) return value;
				DebugLocation(397, 51);
				PushFollow(Follow._expressionITE_in_expressionITE2241);
				elsePart=expressionITE();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(397, 67);
				if (state.backtracking == 0)
				{
					value = new If(cond, ifPart, elsePart);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(35); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionITE", 26);
			LeaveRule("expressionITE", 26);
			LeaveRule_expressionITE();
		}
		DebugLocation(399, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionITE"); }
		return value;

	}
	// $ANTLR end "expressionITE"

	partial void EnterRule_expressionImplies();
	partial void LeaveRule_expressionImplies();

	// $ANTLR start "expressionImplies"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:401:1: expressionImplies returns [Expression value] : exp1= expressionIff ( IMPLIES exp2= expressionIff )* ;
	[GrammarRule("expressionImplies")]
	private Expression expressionImplies()
	{
		EnterRule_expressionImplies();
		EnterRule("expressionImplies", 27);
		TraceIn("expressionImplies", 27);
		Expression value = default(Expression);


		Expression exp1 = default(Expression);
		Expression exp2 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expressionImplies");
		DebugLocation(401, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:405:2: (exp1= expressionIff ( IMPLIES exp2= expressionIff )* )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:405:4: exp1= expressionIff ( IMPLIES exp2= expressionIff )*
			{
			DebugLocation(405, 9);
			PushFollow(Follow._expressionIff_in_expressionImplies2270);
			exp1=expressionIff();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(405, 24);
			if (state.backtracking == 0)
			{
				value = exp1;
			}
			DebugLocation(406, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:406:2: ( IMPLIES exp2= expressionIff )*
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_0 = input.LA(1);

				if ((LA36_0==IMPLIES))
				{
					alt36 = 1;
				}


				} finally { DebugExitDecision(36); }
				switch ( alt36 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:406:3: IMPLIES exp2= expressionIff
					{
					DebugLocation(406, 3);
					Match(input,IMPLIES,Follow._IMPLIES_in_expressionImplies2275); if (state.failed) return value;
					DebugLocation(406, 16);
					PushFollow(Follow._expressionIff_in_expressionImplies2281);
					exp2=expressionIff();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(406, 31);
					if (state.backtracking == 0)
					{
						value = new PrimitiveApplication(PrimitiveApplication.IMPLIES, value, exp2);
					}

					}
					break;

				default:
					goto loop36;
				}
			}

			loop36:
				;

			} finally { DebugExitSubRule(36); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionImplies", 27);
			LeaveRule("expressionImplies", 27);
			LeaveRule_expressionImplies();
		}
		DebugLocation(408, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionImplies"); }
		return value;

	}
	// $ANTLR end "expressionImplies"

	partial void EnterRule_expressionIff();
	partial void LeaveRule_expressionIff();

	// $ANTLR start "expressionIff"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:410:1: expressionIff returns [Expression value] : expressionOr ;
	[GrammarRule("expressionIff")]
	private Expression expressionIff()
	{
		EnterRule_expressionIff();
		EnterRule("expressionIff", 28);
		TraceIn("expressionIff", 28);
		Expression value = default(Expression);


		Expression expressionOr27 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expressionIff");
		DebugLocation(410, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:414:2: ( expressionOr )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:414:4: expressionOr
			{
			DebugLocation(414, 4);
			PushFollow(Follow._expressionOr_in_expressionIff2305);
			expressionOr27=expressionOr();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(414, 16);
			if (state.backtracking == 0)
			{
				value = expressionOr27;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionIff", 28);
			LeaveRule("expressionIff", 28);
			LeaveRule_expressionIff();
		}
		DebugLocation(416, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionIff"); }
		return value;

	}
	// $ANTLR end "expressionIff"

	partial void EnterRule_expressionOr();
	partial void LeaveRule_expressionOr();

	// $ANTLR start "expressionOr"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:418:1: expressionOr returns [Expression value] : and1= expressionAnd ( OR and2= expressionAnd )* ;
	[GrammarRule("expressionOr")]
	private Expression expressionOr()
	{
		EnterRule_expressionOr();
		EnterRule("expressionOr", 29);
		TraceIn("expressionOr", 29);
		Expression value = default(Expression);


		Expression and1 = default(Expression);
		Expression and2 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expressionOr");
		DebugLocation(418, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:422:2: (and1= expressionAnd ( OR and2= expressionAnd )* )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:422:4: and1= expressionAnd ( OR and2= expressionAnd )*
			{
			DebugLocation(422, 9);
			PushFollow(Follow._expressionAnd_in_expressionOr2331);
			and1=expressionAnd();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(422, 24);
			if (state.backtracking == 0)
			{
				value = and1;
			}
			DebugLocation(422, 48);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:422:48: ( OR and2= expressionAnd )*
			try { DebugEnterSubRule(37);
			while (true)
			{
				int alt37=2;
				try { DebugEnterDecision(37, false);
				int LA37_0 = input.LA(1);

				if ((LA37_0==OR))
				{
					alt37 = 1;
				}


				} finally { DebugExitDecision(37); }
				switch ( alt37 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:422:49: OR and2= expressionAnd
					{
					DebugLocation(422, 49);
					Match(input,OR,Follow._OR_in_expressionOr2335); if (state.failed) return value;
					DebugLocation(422, 57);
					PushFollow(Follow._expressionAnd_in_expressionOr2341);
					and2=expressionAnd();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(422, 72);
					if (state.backtracking == 0)
					{
						value = Expression.OR(value, and2);
					}

					}
					break;

				default:
					goto loop37;
				}
			}

			loop37:
				;

			} finally { DebugExitSubRule(37); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionOr", 29);
			LeaveRule("expressionOr", 29);
			LeaveRule_expressionOr();
		}
		DebugLocation(423, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionOr"); }
		return value;

	}
	// $ANTLR end "expressionOr"

	partial void EnterRule_expressionAnd();
	partial void LeaveRule_expressionAnd();

	// $ANTLR start "expressionAnd"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:425:1: expressionAnd returns [Expression value] : equality1= expressionEquality ( AND equality2= expressionEquality )* ;
	[GrammarRule("expressionAnd")]
	private Expression expressionAnd()
	{
		EnterRule_expressionAnd();
		EnterRule("expressionAnd", 30);
		TraceIn("expressionAnd", 30);
		Expression value = default(Expression);


		Expression equality1 = default(Expression);
		Expression equality2 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expressionAnd");
		DebugLocation(425, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:429:2: (equality1= expressionEquality ( AND equality2= expressionEquality )* )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:429:4: equality1= expressionEquality ( AND equality2= expressionEquality )*
			{
			DebugLocation(429, 14);
			PushFollow(Follow._expressionEquality_in_expressionAnd2367);
			equality1=expressionEquality();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(429, 34);
			if (state.backtracking == 0)
			{
				value = equality1;
			}
			DebugLocation(429, 63);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:429:63: ( AND equality2= expressionEquality )*
			try { DebugEnterSubRule(38);
			while (true)
			{
				int alt38=2;
				try { DebugEnterDecision(38, false);
				int LA38_0 = input.LA(1);

				if ((LA38_0==AND))
				{
					alt38 = 1;
				}


				} finally { DebugExitDecision(38); }
				switch ( alt38 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:429:64: AND equality2= expressionEquality
					{
					DebugLocation(429, 64);
					Match(input,AND,Follow._AND_in_expressionAnd2371); if (state.failed) return value;
					DebugLocation(429, 78);
					PushFollow(Follow._expressionEquality_in_expressionAnd2377);
					equality2=expressionEquality();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(429, 98);
					if (state.backtracking == 0)
					{
						value = Expression.AND(value, equality2);
					}

					}
					break;

				default:
					goto loop38;
				}
			}

			loop38:
				;

			} finally { DebugExitSubRule(38); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionAnd", 30);
			LeaveRule("expressionAnd", 30);
			LeaveRule_expressionAnd();
		}
		DebugLocation(430, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionAnd"); }
		return value;

	}
	// $ANTLR end "expressionAnd"

	partial void EnterRule_expressionEquality();
	partial void LeaveRule_expressionEquality();

	// $ANTLR start "expressionEquality"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:432:1: expressionEquality returns [Expression value] : relop1= expressionRelop ( eqNeq relop2= expressionRelop )* ;
	[GrammarRule("expressionEquality")]
	private Expression expressionEquality()
	{
		EnterRule_expressionEquality();
		EnterRule("expressionEquality", 31);
		TraceIn("expressionEquality", 31);
		Expression value = default(Expression);


		Expression relop1 = default(Expression);
		Expression relop2 = default(Expression);
		string eqNeq28 = default(string);


			

		try { DebugEnterRule(GrammarFileName, "expressionEquality");
		DebugLocation(432, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:436:2: (relop1= expressionRelop ( eqNeq relop2= expressionRelop )* )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:436:4: relop1= expressionRelop ( eqNeq relop2= expressionRelop )*
			{
			DebugLocation(436, 11);
			PushFollow(Follow._expressionRelop_in_expressionEquality2403);
			relop1=expressionRelop();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(436, 28);
			if (state.backtracking == 0)
			{
				value = relop1;
			}
			DebugLocation(437, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:437:2: ( eqNeq relop2= expressionRelop )*
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=2;
				try { DebugEnterDecision(39, false);
				int LA39_0 = input.LA(1);

				if ((LA39_0==EQ||LA39_0==NE))
				{
					alt39 = 1;
				}


				} finally { DebugExitDecision(39); }
				switch ( alt39 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:437:3: eqNeq relop2= expressionRelop
					{
					DebugLocation(437, 3);
					PushFollow(Follow._eqNeq_in_expressionEquality2409);
					eqNeq28=eqNeq();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(437, 16);
					PushFollow(Follow._expressionRelop_in_expressionEquality2415);
					relop2=expressionRelop();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(437, 33);
					if (state.backtracking == 0)
					{
						value = new PrimitiveApplication(eqNeq28, value, relop2);
					}

					}
					break;

				default:
					goto loop39;
				}
			}

			loop39:
				;

			} finally { DebugExitSubRule(39); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionEquality", 31);
			LeaveRule("expressionEquality", 31);
			LeaveRule_expressionEquality();
		}
		DebugLocation(438, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionEquality"); }
		return value;

	}
	// $ANTLR end "expressionEquality"

	partial void EnterRule_expressionRelop();
	partial void LeaveRule_expressionRelop();

	// $ANTLR start "expressionRelop"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:440:1: expressionRelop returns [Expression value] : plusminus1= expressionPlusMinus ( ltGt plusminus2= expressionPlusMinus )* ;
	[GrammarRule("expressionRelop")]
	private Expression expressionRelop()
	{
		EnterRule_expressionRelop();
		EnterRule("expressionRelop", 32);
		TraceIn("expressionRelop", 32);
		Expression value = default(Expression);


		Expression plusminus1 = default(Expression);
		Expression plusminus2 = default(Expression);
		PrismModelParser.ltGt_return ltGt29 = default(PrismModelParser.ltGt_return);


			

		try { DebugEnterRule(GrammarFileName, "expressionRelop");
		DebugLocation(440, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:444:2: (plusminus1= expressionPlusMinus ( ltGt plusminus2= expressionPlusMinus )* )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:444:4: plusminus1= expressionPlusMinus ( ltGt plusminus2= expressionPlusMinus )*
			{
			DebugLocation(444, 15);
			PushFollow(Follow._expressionPlusMinus_in_expressionRelop2441);
			plusminus1=expressionPlusMinus();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(444, 36);
			if (state.backtracking == 0)
			{
				value = plusminus1;
			}
			DebugLocation(445, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:445:2: ( ltGt plusminus2= expressionPlusMinus )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_0 = input.LA(1);

				if ((LA40_0==GE||LA40_0==GT||LA40_0==LE||LA40_0==LT))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:445:3: ltGt plusminus2= expressionPlusMinus
					{
					DebugLocation(445, 3);
					PushFollow(Follow._ltGt_in_expressionRelop2447);
					ltGt29=ltGt();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(445, 19);
					PushFollow(Follow._expressionPlusMinus_in_expressionRelop2453);
					plusminus2=expressionPlusMinus();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(445, 40);
					if (state.backtracking == 0)
					{
						value = new PrimitiveApplication((ltGt29!=null?ltGt29.value:default(string)), value, plusminus2);
					}

					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionRelop", 32);
			LeaveRule("expressionRelop", 32);
			LeaveRule_expressionRelop();
		}
		DebugLocation(446, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionRelop"); }
		return value;

	}
	// $ANTLR end "expressionRelop"

	partial void EnterRule_expressionPlusMinus();
	partial void LeaveRule_expressionPlusMinus();

	// $ANTLR start "expressionPlusMinus"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:448:1: expressionPlusMinus returns [Expression value] : timediv1= expressionTimesDivide ( ( PLUS | MINUS ) timediv2= expressionTimesDivide )* ;
	[GrammarRule("expressionPlusMinus")]
	private Expression expressionPlusMinus()
	{
		EnterRule_expressionPlusMinus();
		EnterRule("expressionPlusMinus", 33);
		TraceIn("expressionPlusMinus", 33);
		Expression value = default(Expression);


		Expression timediv1 = default(Expression);
		Expression timediv2 = default(Expression);


			string op = PrimitiveApplication.PLUS;

		try { DebugEnterRule(GrammarFileName, "expressionPlusMinus");
		DebugLocation(448, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:452:2: (timediv1= expressionTimesDivide ( ( PLUS | MINUS ) timediv2= expressionTimesDivide )* )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:452:4: timediv1= expressionTimesDivide ( ( PLUS | MINUS ) timediv2= expressionTimesDivide )*
			{
			DebugLocation(452, 13);
			PushFollow(Follow._expressionTimesDivide_in_expressionPlusMinus2479);
			timediv1=expressionTimesDivide();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(452, 36);
			if (state.backtracking == 0)
			{
				value = timediv1;
			}
			DebugLocation(453, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:453:2: ( ( PLUS | MINUS ) timediv2= expressionTimesDivide )*
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				try
				{
					alt42 = dfa42.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(42); }
				switch ( alt42 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:454:3: ( PLUS | MINUS ) timediv2= expressionTimesDivide
					{
					DebugLocation(454, 3);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:454:3: ( PLUS | MINUS )
					int alt41=2;
					try { DebugEnterSubRule(41);
					try { DebugEnterDecision(41, false);
					int LA41_0 = input.LA(1);

					if ((LA41_0==PLUS))
					{
						alt41 = 1;
					}
					else if ((LA41_0==MINUS))
					{
						alt41 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 41, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(41); }
					switch (alt41)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:454:4: PLUS
						{
						DebugLocation(454, 4);
						Match(input,PLUS,Follow._PLUS_in_expressionPlusMinus2489); if (state.failed) return value;
						DebugLocation(454, 8);
						if (state.backtracking == 0)
						{
							op = PrimitiveApplication.PLUS;
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:454:44: MINUS
						{
						DebugLocation(454, 44);
						Match(input,MINUS,Follow._MINUS_in_expressionPlusMinus2494); if (state.failed) return value;
						DebugLocation(454, 50);
						if (state.backtracking == 0)
						{
							op = PrimitiveApplication.MINUS;
						}

						}
						break;

					}
					} finally { DebugExitSubRule(41); }

					DebugLocation(455, 12);
					PushFollow(Follow._expressionTimesDivide_in_expressionPlusMinus2505);
					timediv2=expressionTimesDivide();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(455, 35);
					if (state.backtracking == 0)
					{
						value = new PrimitiveApplication(op, value, timediv2);
					}

					}
					break;

				default:
					goto loop42;
				}
			}

			loop42:
				;

			} finally { DebugExitSubRule(42); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionPlusMinus", 33);
			LeaveRule("expressionPlusMinus", 33);
			LeaveRule_expressionPlusMinus();
		}
		DebugLocation(457, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionPlusMinus"); }
		return value;

	}
	// $ANTLR end "expressionPlusMinus"

	partial void EnterRule_expressionTimesDivide();
	partial void LeaveRule_expressionTimesDivide();

	// $ANTLR start "expressionTimesDivide"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:459:1: expressionTimesDivide returns [Expression value] : unaryminus1= expressionUnaryMinus ( ( TIMES | DIVIDE ) unaryminus2= expressionUnaryMinus )* ;
	[GrammarRule("expressionTimesDivide")]
	private Expression expressionTimesDivide()
	{
		EnterRule_expressionTimesDivide();
		EnterRule("expressionTimesDivide", 34);
		TraceIn("expressionTimesDivide", 34);
		Expression value = default(Expression);


		Expression unaryminus1 = default(Expression);
		Expression unaryminus2 = default(Expression);


			string op = PrimitiveApplication.PLUS;

		try { DebugEnterRule(GrammarFileName, "expressionTimesDivide");
		DebugLocation(459, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:463:2: (unaryminus1= expressionUnaryMinus ( ( TIMES | DIVIDE ) unaryminus2= expressionUnaryMinus )* )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:463:4: unaryminus1= expressionUnaryMinus ( ( TIMES | DIVIDE ) unaryminus2= expressionUnaryMinus )*
			{
			DebugLocation(463, 16);
			PushFollow(Follow._expressionUnaryMinus_in_expressionTimesDivide2533);
			unaryminus1=expressionUnaryMinus();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(463, 38);
			if (state.backtracking == 0)
			{
				value = unaryminus1;
			}
			DebugLocation(464, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:464:2: ( ( TIMES | DIVIDE ) unaryminus2= expressionUnaryMinus )*
			try { DebugEnterSubRule(44);
			while (true)
			{
				int alt44=2;
				try { DebugEnterDecision(44, false);
				int LA44_0 = input.LA(1);

				if ((LA44_0==DIVIDE||LA44_0==TIMES))
				{
					alt44 = 1;
				}


				} finally { DebugExitDecision(44); }
				switch ( alt44 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:465:3: ( TIMES | DIVIDE ) unaryminus2= expressionUnaryMinus
					{
					DebugLocation(465, 3);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:465:3: ( TIMES | DIVIDE )
					int alt43=2;
					try { DebugEnterSubRule(43);
					try { DebugEnterDecision(43, false);
					int LA43_0 = input.LA(1);

					if ((LA43_0==TIMES))
					{
						alt43 = 1;
					}
					else if ((LA43_0==DIVIDE))
					{
						alt43 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 43, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(43); }
					switch (alt43)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:465:4: TIMES
						{
						DebugLocation(465, 4);
						Match(input,TIMES,Follow._TIMES_in_expressionTimesDivide2543); if (state.failed) return value;
						DebugLocation(465, 9);
						if (state.backtracking == 0)
						{
							op = PrimitiveApplication.TIMES;
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:465:46: DIVIDE
						{
						DebugLocation(465, 46);
						Match(input,DIVIDE,Follow._DIVIDE_in_expressionTimesDivide2548); if (state.failed) return value;
						DebugLocation(465, 53);
						if (state.backtracking == 0)
						{
							op = PrimitiveApplication.DIVIDE;
						}

						}
						break;

					}
					} finally { DebugExitSubRule(43); }

					DebugLocation(466, 15);
					PushFollow(Follow._expressionUnaryMinus_in_expressionTimesDivide2559);
					unaryminus2=expressionUnaryMinus();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(466, 37);
					if (state.backtracking == 0)
					{
						value = new PrimitiveApplication(op, value, unaryminus2);
					}

					}
					break;

				default:
					goto loop44;
				}
			}

			loop44:
				;

			} finally { DebugExitSubRule(44); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionTimesDivide", 34);
			LeaveRule("expressionTimesDivide", 34);
			LeaveRule_expressionTimesDivide();
		}
		DebugLocation(468, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionTimesDivide"); }
		return value;

	}
	// $ANTLR end "expressionTimesDivide"

	partial void EnterRule_expressionUnaryMinus();
	partial void LeaveRule_expressionUnaryMinus();

	// $ANTLR start "expressionUnaryMinus"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:470:1: expressionUnaryMinus returns [Expression value] : ( MINUS minusBasic= expressionBasic | NOT notBasic= expressionBasic |othersBasic= expressionBasic );
	[GrammarRule("expressionUnaryMinus")]
	private Expression expressionUnaryMinus()
	{
		EnterRule_expressionUnaryMinus();
		EnterRule("expressionUnaryMinus", 35);
		TraceIn("expressionUnaryMinus", 35);
		Expression value = default(Expression);


		Expression minusBasic = default(Expression);
		Expression notBasic = default(Expression);
		Expression othersBasic = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expressionUnaryMinus");
		DebugLocation(470, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:474:2: ( MINUS minusBasic= expressionBasic | NOT notBasic= expressionBasic |othersBasic= expressionBasic )
			int alt45=3;
			try { DebugEnterDecision(45, false);
			switch (input.LA(1))
			{
			case MINUS:
				{
				alt45 = 1;
				}
				break;
			case NOT:
				{
				alt45 = 2;
				}
				break;
			case A:
			case DQUOTE:
			case E:
			case FALSE:
			case FILTER:
			case FUNC:
			case ID:
			case INT_NUM:
			case LPARENTH:
			case MAX:
			case MIN:
			case P:
			case PMAX:
			case PMIN:
			case R:
			case RMAX:
			case RMIN:
			case S:
			case TRUE:
				{
				alt45 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 45, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:474:4: MINUS minusBasic= expressionBasic
				{
				DebugLocation(474, 4);
				Match(input,MINUS,Follow._MINUS_in_expressionUnaryMinus2583); if (state.failed) return value;
				DebugLocation(474, 21);
				PushFollow(Follow._expressionBasic_in_expressionUnaryMinus2589);
				minusBasic=expressionBasic();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(474, 38);
				if (state.backtracking == 0)
				{
					value = new PrimitiveApplication(PrimitiveApplication.MINUS, minusBasic);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:475:4: NOT notBasic= expressionBasic
				{
				DebugLocation(475, 4);
				Match(input,NOT,Follow._NOT_in_expressionUnaryMinus2595); if (state.failed) return value;
				DebugLocation(475, 17);
				PushFollow(Follow._expressionBasic_in_expressionUnaryMinus2601);
				notBasic=expressionBasic();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(475, 34);
				if (state.backtracking == 0)
				{
					value = new PrimitiveApplication(PrimitiveApplication.NOT, notBasic);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:476:4: othersBasic= expressionBasic
				{
				DebugLocation(476, 16);
				PushFollow(Follow._expressionBasic_in_expressionUnaryMinus2611);
				othersBasic=expressionBasic();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(476, 33);
				if (state.backtracking == 0)
				{
					value = othersBasic;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionUnaryMinus", 35);
			LeaveRule("expressionUnaryMinus", 35);
			LeaveRule_expressionUnaryMinus();
		}
		DebugLocation(477, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionUnaryMinus"); }
		return value;

	}
	// $ANTLR end "expressionUnaryMinus"

	partial void EnterRule_expressionBasic();
	partial void LeaveRule_expressionBasic();

	// $ANTLR start "expressionBasic"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:479:1: expressionBasic returns [Expression value] : ( expressionLiteral | expressionFuncMinMax | expressionParenth | expressionFuncOrIdent | expressionFuncOldStyle | expressionProb | expressionSS | expressionReward | expressionExists | expressionForAll | expressionLabel | expressionFilter );
	[GrammarRule("expressionBasic")]
	private Expression expressionBasic()
	{
		EnterRule_expressionBasic();
		EnterRule("expressionBasic", 36);
		TraceIn("expressionBasic", 36);
		Expression value = default(Expression);


		Expression expressionLiteral30 = default(Expression);
		Expression expressionFuncMinMax31 = default(Expression);
		Expression expressionParenth32 = default(Expression);
		Expression expressionFuncOrIdent33 = default(Expression);
		Expression expressionFuncOldStyle34 = default(Expression);
		Expression expressionProb35 = default(Expression);
		Expression expressionSS36 = default(Expression);
		Expression expressionReward37 = default(Expression);
		Expression expressionExists38 = default(Expression);
		Expression expressionForAll39 = default(Expression);
		Expression expressionLabel40 = default(Expression);
		Expression expressionFilter41 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expressionBasic");
		DebugLocation(479, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:483:2: ( expressionLiteral | expressionFuncMinMax | expressionParenth | expressionFuncOrIdent | expressionFuncOldStyle | expressionProb | expressionSS | expressionReward | expressionExists | expressionForAll | expressionLabel | expressionFilter )
			int alt46=12;
			try { DebugEnterDecision(46, false);
			switch (input.LA(1))
			{
			case FALSE:
			case INT_NUM:
			case TRUE:
				{
				alt46 = 1;
				}
				break;
			case MAX:
			case MIN:
				{
				alt46 = 2;
				}
				break;
			case LPARENTH:
				{
				alt46 = 3;
				}
				break;
			case ID:
				{
				alt46 = 4;
				}
				break;
			case FUNC:
				{
				alt46 = 5;
				}
				break;
			case P:
			case PMAX:
			case PMIN:
				{
				alt46 = 6;
				}
				break;
			case S:
				{
				alt46 = 7;
				}
				break;
			case R:
			case RMAX:
			case RMIN:
				{
				alt46 = 8;
				}
				break;
			case E:
				{
				alt46 = 9;
				}
				break;
			case A:
				{
				alt46 = 10;
				}
				break;
			case DQUOTE:
				{
				alt46 = 11;
				}
				break;
			case FILTER:
				{
				alt46 = 12;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:483:4: expressionLiteral
				{
				DebugLocation(483, 4);
				PushFollow(Follow._expressionLiteral_in_expressionBasic2631);
				expressionLiteral30=expressionLiteral();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(483, 21);
				if (state.backtracking == 0)
				{
					value = expressionLiteral30;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:484:4: expressionFuncMinMax
				{
				DebugLocation(484, 4);
				PushFollow(Follow._expressionFuncMinMax_in_expressionBasic2637);
				expressionFuncMinMax31=expressionFuncMinMax();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(484, 24);
				if (state.backtracking == 0)
				{
					value = expressionFuncMinMax31;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:485:4: expressionParenth
				{
				DebugLocation(485, 4);
				PushFollow(Follow._expressionParenth_in_expressionBasic2643);
				expressionParenth32=expressionParenth();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(485, 21);
				if (state.backtracking == 0)
				{
					value = expressionParenth32;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:486:4: expressionFuncOrIdent
				{
				DebugLocation(486, 4);
				PushFollow(Follow._expressionFuncOrIdent_in_expressionBasic2649);
				expressionFuncOrIdent33=expressionFuncOrIdent();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(486, 25);
				if (state.backtracking == 0)
				{
					value = expressionFuncOrIdent33;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:487:4: expressionFuncOldStyle
				{
				DebugLocation(487, 4);
				PushFollow(Follow._expressionFuncOldStyle_in_expressionBasic2655);
				expressionFuncOldStyle34=expressionFuncOldStyle();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(487, 26);
				if (state.backtracking == 0)
				{
					value = expressionFuncOldStyle34;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:489:4: expressionProb
				{
				DebugLocation(489, 4);
				PushFollow(Follow._expressionProb_in_expressionBasic2663);
				expressionProb35=expressionProb();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(489, 18);
				if (state.backtracking == 0)
				{
					value = expressionProb35;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:490:4: expressionSS
				{
				DebugLocation(490, 4);
				PushFollow(Follow._expressionSS_in_expressionBasic2669);
				expressionSS36=expressionSS();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(490, 16);
				if (state.backtracking == 0)
				{
					value = expressionSS36;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:491:4: expressionReward
				{
				DebugLocation(491, 4);
				PushFollow(Follow._expressionReward_in_expressionBasic2675);
				expressionReward37=expressionReward();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(491, 20);
				if (state.backtracking == 0)
				{
					value = expressionReward37;
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:492:4: expressionExists
				{
				DebugLocation(492, 4);
				PushFollow(Follow._expressionExists_in_expressionBasic2681);
				expressionExists38=expressionExists();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(492, 20);
				if (state.backtracking == 0)
				{
					value = expressionExists38;
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:493:4: expressionForAll
				{
				DebugLocation(493, 4);
				PushFollow(Follow._expressionForAll_in_expressionBasic2687);
				expressionForAll39=expressionForAll();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(493, 20);
				if (state.backtracking == 0)
				{
					value = expressionForAll39;
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:494:4: expressionLabel
				{
				DebugLocation(494, 4);
				PushFollow(Follow._expressionLabel_in_expressionBasic2693);
				expressionLabel40=expressionLabel();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(494, 19);
				if (state.backtracking == 0)
				{
					value = expressionLabel40;
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:495:4: expressionFilter
				{
				DebugLocation(495, 4);
				PushFollow(Follow._expressionFilter_in_expressionBasic2699);
				expressionFilter41=expressionFilter();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(495, 20);
				if (state.backtracking == 0)
				{
					value = expressionFilter41;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionBasic", 36);
			LeaveRule("expressionBasic", 36);
			LeaveRule_expressionBasic();
		}
		DebugLocation(496, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionBasic"); }
		return value;

	}
	// $ANTLR end "expressionBasic"

	partial void EnterRule_expressionLiteral();
	partial void LeaveRule_expressionLiteral();

	// $ANTLR start "expressionLiteral"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:498:1: expressionLiteral returns [Expression value] : ( intNumber | doubleNumber | TRUE | FALSE );
	[GrammarRule("expressionLiteral")]
	private Expression expressionLiteral()
	{
		EnterRule_expressionLiteral();
		EnterRule("expressionLiteral", 37);
		TraceIn("expressionLiteral", 37);
		Expression value = default(Expression);


		Expression intNumber42 = default(Expression);
		Expression doubleNumber43 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expressionLiteral");
		DebugLocation(498, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:502:2: ( intNumber | doubleNumber | TRUE | FALSE )
			int alt47=4;
			try { DebugEnterDecision(47, false);
			switch (input.LA(1))
			{
			case INT_NUM:
				{
				int LA47_1 = input.LA(2);

				if ((LA47_1==EOF||(LA47_1>=A && LA47_1<=AND)||(LA47_1>=COLON && LA47_1<=COMMA)||(LA47_1>=CONST && LA47_1<=DIVIDE)||LA47_1==DOTS||(LA47_1>=DQUOTE && LA47_1<=ENDINIT)||(LA47_1>=EQ && LA47_1<=GT)||LA47_1==ID||(LA47_1>=IMPLIES && LA47_1<=INIT)||LA47_1==INT_NUM||(LA47_1>=LABEL && LA47_1<=LE)||(LA47_1>=LPARENTH && LA47_1<=PMIN)||(LA47_1>=PROB && LA47_1<=PROBABILISTIC)||(LA47_1>=QMARK && LA47_1<=RBRACKET)||(LA47_1>=REWARDS && LA47_1<=STOCHASTIC)||(LA47_1>=TIMES && LA47_1<=W)||LA47_1==X))
				{
					alt47 = 1;
				}
				else if ((LA47_1==DOT))
				{
					alt47 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 47, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case TRUE:
				{
				alt47 = 3;
				}
				break;
			case FALSE:
				{
				alt47 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:502:4: intNumber
				{
				DebugLocation(502, 4);
				PushFollow(Follow._intNumber_in_expressionLiteral2719);
				intNumber42=intNumber();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(502, 13);
				if (state.backtracking == 0)
				{
					value = intNumber42;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:503:4: doubleNumber
				{
				DebugLocation(503, 4);
				PushFollow(Follow._doubleNumber_in_expressionLiteral2725);
				doubleNumber43=doubleNumber();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(503, 16);
				if (state.backtracking == 0)
				{
					value = doubleNumber43;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:504:4: TRUE
				{
				DebugLocation(504, 4);
				Match(input,TRUE,Follow._TRUE_in_expressionLiteral2731); if (state.failed) return value;
				DebugLocation(504, 9);
				if (state.backtracking == 0)
				{
					value = new BoolConstant(true);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:505:4: FALSE
				{
				DebugLocation(505, 4);
				Match(input,FALSE,Follow._FALSE_in_expressionLiteral2738); if (state.failed) return value;
				DebugLocation(505, 10);
				if (state.backtracking == 0)
				{
					value = new BoolConstant(false);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionLiteral", 37);
			LeaveRule("expressionLiteral", 37);
			LeaveRule_expressionLiteral();
		}
		DebugLocation(506, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionLiteral"); }
		return value;

	}
	// $ANTLR end "expressionLiteral"

	partial void EnterRule_intNumber();
	partial void LeaveRule_intNumber();

	// $ANTLR start "intNumber"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:509:1: intNumber returns [Expression value] : INT_NUM ;
	[GrammarRule("intNumber")]
	private Expression intNumber()
	{
		EnterRule_intNumber();
		EnterRule("intNumber", 38);
		TraceIn("intNumber", 38);
		Expression value = default(Expression);


		IToken INT_NUM44 = default(IToken);


			

		try { DebugEnterRule(GrammarFileName, "intNumber");
		DebugLocation(509, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:513:2: ( INT_NUM )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:513:4: INT_NUM
			{
			DebugLocation(513, 4);
			INT_NUM44=(IToken)Match(input,INT_NUM,Follow._INT_NUM_in_intNumber2760); if (state.failed) return value;
			DebugLocation(513, 12);
			if (state.backtracking == 0)
			{
				value = new IntConstant(int.Parse((INT_NUM44!=null?INT_NUM44.Text:null)));
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("intNumber", 38);
			LeaveRule("intNumber", 38);
			LeaveRule_intNumber();
		}
		DebugLocation(514, 0);
		} finally { DebugExitRule(GrammarFileName, "intNumber"); }
		return value;

	}
	// $ANTLR end "intNumber"

	partial void EnterRule_doubleNumber();
	partial void LeaveRule_doubleNumber();

	// $ANTLR start "doubleNumber"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:517:1: doubleNumber returns [Expression value] : zint= INT_NUM ( DOT dint= INT_NUM ) ;
	[GrammarRule("doubleNumber")]
	private Expression doubleNumber()
	{
		EnterRule_doubleNumber();
		EnterRule("doubleNumber", 39);
		TraceIn("doubleNumber", 39);
		Expression value = default(Expression);


		IToken zint = default(IToken);
		IToken dint = default(IToken);


			string number = string.Empty;

		try { DebugEnterRule(GrammarFileName, "doubleNumber");
		DebugLocation(517, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:521:2: (zint= INT_NUM ( DOT dint= INT_NUM ) )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:521:4: zint= INT_NUM ( DOT dint= INT_NUM )
			{
			DebugLocation(521, 9);
			zint=(IToken)Match(input,INT_NUM,Follow._INT_NUM_in_doubleNumber2786); if (state.failed) return value;
			DebugLocation(521, 18);
			if (state.backtracking == 0)
			{
				number += (zint!=null?zint.Text:null);
			}
			DebugLocation(521, 42);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:521:42: ( DOT dint= INT_NUM )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:521:43: DOT dint= INT_NUM
			{
			DebugLocation(521, 43);
			Match(input,DOT,Follow._DOT_in_doubleNumber2790); if (state.failed) return value;
			DebugLocation(521, 52);
			dint=(IToken)Match(input,INT_NUM,Follow._INT_NUM_in_doubleNumber2796); if (state.failed) return value;
			DebugLocation(521, 61);
			if (state.backtracking == 0)
			{
				number+= "." + (dint!=null?dint.Text:null); value = new DoubleConstant(double.Parse(number));
			}

			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("doubleNumber", 39);
			LeaveRule("doubleNumber", 39);
			LeaveRule_doubleNumber();
		}
		DebugLocation(522, 0);
		} finally { DebugExitRule(GrammarFileName, "doubleNumber"); }
		return value;

	}
	// $ANTLR end "doubleNumber"

	partial void EnterRule_expressionFuncMinMax();
	partial void LeaveRule_expressionFuncMinMax();

	// $ANTLR start "expressionFuncMinMax"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:525:1: expressionFuncMinMax returns [Expression value] : ( MIN | MAX ) LPARENTH expressionFuncArgs[args] RPARENTH ;
	[GrammarRule("expressionFuncMinMax")]
	private Expression expressionFuncMinMax()
	{
		EnterRule_expressionFuncMinMax();
		EnterRule("expressionFuncMinMax", 40);
		TraceIn("expressionFuncMinMax", 40);
		Expression value = default(Expression);



			bool isMin = false;
			List<Expression> args = new List<Expression>();

		try { DebugEnterRule(GrammarFileName, "expressionFuncMinMax");
		DebugLocation(525, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:530:2: ( ( MIN | MAX ) LPARENTH expressionFuncArgs[args] RPARENTH )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:530:4: ( MIN | MAX ) LPARENTH expressionFuncArgs[args] RPARENTH
			{
			DebugLocation(530, 4);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:530:4: ( MIN | MAX )
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_0 = input.LA(1);

			if ((LA48_0==MIN))
			{
				alt48 = 1;
			}
			else if ((LA48_0==MAX))
			{
				alt48 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 48, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:530:5: MIN
				{
				DebugLocation(530, 5);
				Match(input,MIN,Follow._MIN_in_expressionFuncMinMax2820); if (state.failed) return value;
				DebugLocation(530, 8);
				if (state.backtracking == 0)
				{
					isMin = true;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:530:26: MAX
				{
				DebugLocation(530, 26);
				Match(input,MAX,Follow._MAX_in_expressionFuncMinMax2825); if (state.failed) return value;
				DebugLocation(530, 29);
				if (state.backtracking == 0)
				{
					isMin = false;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(48); }

			DebugLocation(531, 2);
			Match(input,LPARENTH,Follow._LPARENTH_in_expressionFuncMinMax2830); if (state.failed) return value;
			DebugLocation(531, 12);
			PushFollow(Follow._expressionFuncArgs_in_expressionFuncMinMax2833);
			expressionFuncArgs(args);
			PopFollow();
			if (state.failed) return value;
			DebugLocation(531, 37);
			Match(input,RPARENTH,Follow._RPARENTH_in_expressionFuncMinMax2836); if (state.failed) return value;
			DebugLocation(531, 45);
			if (state.backtracking == 0)
			{
				if(isMin) return Expression.MIN(args); else return Expression.MAX(args);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionFuncMinMax", 40);
			LeaveRule("expressionFuncMinMax", 40);
			LeaveRule_expressionFuncMinMax();
		}
		DebugLocation(532, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionFuncMinMax"); }
		return value;

	}
	// $ANTLR end "expressionFuncMinMax"

	partial void EnterRule_expressionFuncArgs();
	partial void LeaveRule_expressionFuncArgs();

	// $ANTLR start "expressionFuncArgs"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:535:1: expressionFuncArgs[List<Expression> args] : arg1= expression ( COMMA arg2= expression )* ;
	[GrammarRule("expressionFuncArgs")]
	private void expressionFuncArgs(List<Expression> args)
	{
		EnterRule_expressionFuncArgs();
		EnterRule("expressionFuncArgs", 41);
		TraceIn("expressionFuncArgs", 41);
		Expression arg1 = default(Expression);
		Expression arg2 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expressionFuncArgs");
		DebugLocation(535, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:539:2: (arg1= expression ( COMMA arg2= expression )* )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:539:4: arg1= expression ( COMMA arg2= expression )*
			{
			DebugLocation(539, 9);
			PushFollow(Follow._expression_in_expressionFuncArgs2858);
			arg1=expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(539, 21);
			if (state.backtracking == 0)
			{
				args.Add(arg1);
			}
			DebugLocation(539, 47);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:539:47: ( COMMA arg2= expression )*
			try { DebugEnterSubRule(49);
			while (true)
			{
				int alt49=2;
				try { DebugEnterDecision(49, false);
				int LA49_0 = input.LA(1);

				if ((LA49_0==COMMA))
				{
					alt49 = 1;
				}


				} finally { DebugExitDecision(49); }
				switch ( alt49 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:539:48: COMMA arg2= expression
					{
					DebugLocation(539, 48);
					Match(input,COMMA,Follow._COMMA_in_expressionFuncArgs2862); if (state.failed) return;
					DebugLocation(539, 59);
					PushFollow(Follow._expression_in_expressionFuncArgs2868);
					arg2=expression();
					PopFollow();
					if (state.failed) return;
					DebugLocation(539, 71);
					if (state.backtracking == 0)
					{
						args.Add(arg2);
					}

					}
					break;

				default:
					goto loop49;
				}
			}

			loop49:
				;

			} finally { DebugExitSubRule(49); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionFuncArgs", 41);
			LeaveRule("expressionFuncArgs", 41);
			LeaveRule_expressionFuncArgs();
		}
		DebugLocation(540, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionFuncArgs"); }
		return;

	}
	// $ANTLR end "expressionFuncArgs"

	partial void EnterRule_expressionParenth();
	partial void LeaveRule_expressionParenth();

	// $ANTLR start "expressionParenth"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:542:1: expressionParenth returns [Expression value] : LPARENTH expression RPARENTH ;
	[GrammarRule("expressionParenth")]
	private Expression expressionParenth()
	{
		EnterRule_expressionParenth();
		EnterRule("expressionParenth", 42);
		TraceIn("expressionParenth", 42);
		Expression value = default(Expression);


		Expression expression45 = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "expressionParenth");
		DebugLocation(542, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:546:2: ( LPARENTH expression RPARENTH )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:546:4: LPARENTH expression RPARENTH
			{
			DebugLocation(546, 4);
			Match(input,LPARENTH,Follow._LPARENTH_in_expressionParenth2890); if (state.failed) return value;
			DebugLocation(546, 13);
			PushFollow(Follow._expression_in_expressionParenth2892);
			expression45=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(546, 23);
			if (state.backtracking == 0)
			{
				value = expression45;
			}
			DebugLocation(546, 53);
			Match(input,RPARENTH,Follow._RPARENTH_in_expressionParenth2895); if (state.failed) return value;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionParenth", 42);
			LeaveRule("expressionParenth", 42);
			LeaveRule_expressionParenth();
		}
		DebugLocation(547, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionParenth"); }
		return value;

	}
	// $ANTLR end "expressionParenth"

	partial void EnterRule_expressionFuncOrIdent();
	partial void LeaveRule_expressionFuncOrIdent();

	// $ANTLR start "expressionFuncOrIdent"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:549:1: expressionFuncOrIdent returns [Expression value] : ID ( LPARENTH expressionFuncArgs[argsOfFunc] RPARENTH )? ;
	[GrammarRule("expressionFuncOrIdent")]
	private Expression expressionFuncOrIdent()
	{
		EnterRule_expressionFuncOrIdent();
		EnterRule("expressionFuncOrIdent", 43);
		TraceIn("expressionFuncOrIdent", 43);
		Expression value = default(Expression);


		IToken ID46 = default(IToken);


			argsOfFunc.Clear();
			string s = string.Empty;

		try { DebugEnterRule(GrammarFileName, "expressionFuncOrIdent");
		DebugLocation(549, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:554:2: ( ID ( LPARENTH expressionFuncArgs[argsOfFunc] RPARENTH )? )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:554:4: ID ( LPARENTH expressionFuncArgs[argsOfFunc] RPARENTH )?
			{
			DebugLocation(554, 4);
			ID46=(IToken)Match(input,ID,Follow._ID_in_expressionFuncOrIdent2914); if (state.failed) return value;
			DebugLocation(554, 6);
			if (state.backtracking == 0)
			{
				s = (ID46!=null?ID46.Text:null); value = new Variable(s);
			}
			DebugLocation(556, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:556:2: ( LPARENTH expressionFuncArgs[argsOfFunc] RPARENTH )?
			int alt50=2;
			try { DebugEnterSubRule(50);
			try { DebugEnterDecision(50, false);
			try
			{
				alt50 = dfa50.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:556:4: LPARENTH expressionFuncArgs[argsOfFunc] RPARENTH
				{
				DebugLocation(556, 4);
				Match(input,LPARENTH,Follow._LPARENTH_in_expressionFuncOrIdent2922); if (state.failed) return value;
				DebugLocation(556, 13);
				PushFollow(Follow._expressionFuncArgs_in_expressionFuncOrIdent2924);
				expressionFuncArgs(argsOfFunc);
				PopFollow();
				if (state.failed) return value;
				DebugLocation(556, 43);
				if (state.backtracking == 0)
				{
					value = new FuncNary(s, argsOfFunc);
				}
				DebugLocation(556, 82);
				Match(input,RPARENTH,Follow._RPARENTH_in_expressionFuncOrIdent2928); if (state.failed) return value;

				}
				break;

			}
			} finally { DebugExitSubRule(50); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionFuncOrIdent", 43);
			LeaveRule("expressionFuncOrIdent", 43);
			LeaveRule_expressionFuncOrIdent();
		}
		DebugLocation(557, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionFuncOrIdent"); }
		return value;

	}
	// $ANTLR end "expressionFuncOrIdent"

	partial void EnterRule_expressionFuncOldStyle();
	partial void LeaveRule_expressionFuncOldStyle();

	// $ANTLR start "expressionFuncOldStyle"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:559:1: expressionFuncOldStyle returns [Expression value] : FUNC LPARENTH ( MIN | MAX | ID ) COMMA expressionFuncArgs[args] RPARENTH ;
	[GrammarRule("expressionFuncOldStyle")]
	private Expression expressionFuncOldStyle()
	{
		EnterRule_expressionFuncOldStyle();
		EnterRule("expressionFuncOldStyle", 44);
		TraceIn("expressionFuncOldStyle", 44);
		Expression value = default(Expression);


		IToken ID47 = default(IToken);


			argsOfFunc.Clear();
			List<Expression> args = new List<Expression>();
			string s = string.Empty;

		try { DebugEnterRule(GrammarFileName, "expressionFuncOldStyle");
		DebugLocation(559, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:565:2: ( FUNC LPARENTH ( MIN | MAX | ID ) COMMA expressionFuncArgs[args] RPARENTH )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:565:4: FUNC LPARENTH ( MIN | MAX | ID ) COMMA expressionFuncArgs[args] RPARENTH
			{
			DebugLocation(565, 4);
			Match(input,FUNC,Follow._FUNC_in_expressionFuncOldStyle2949); if (state.failed) return value;
			DebugLocation(565, 9);
			Match(input,LPARENTH,Follow._LPARENTH_in_expressionFuncOldStyle2951); if (state.failed) return value;
			DebugLocation(565, 18);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:565:18: ( MIN | MAX | ID )
			int alt51=3;
			try { DebugEnterSubRule(51);
			try { DebugEnterDecision(51, false);
			switch (input.LA(1))
			{
			case MIN:
				{
				alt51 = 1;
				}
				break;
			case MAX:
				{
				alt51 = 2;
				}
				break;
			case ID:
				{
				alt51 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 51, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:565:20: MIN
				{
				DebugLocation(565, 20);
				Match(input,MIN,Follow._MIN_in_expressionFuncOldStyle2955); if (state.failed) return value;
				DebugLocation(565, 24);
				if (state.backtracking == 0)
				{
					 s = "min"; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:565:41: MAX
				{
				DebugLocation(565, 41);
				Match(input,MAX,Follow._MAX_in_expressionFuncOldStyle2961); if (state.failed) return value;
				DebugLocation(565, 45);
				if (state.backtracking == 0)
				{
					 s = "max"; 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:565:62: ID
				{
				DebugLocation(565, 62);
				ID47=(IToken)Match(input,ID,Follow._ID_in_expressionFuncOldStyle2967); if (state.failed) return value;
				DebugLocation(565, 64);
				if (state.backtracking == 0)
				{
					s = (ID47!=null?ID47.Text:null);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(51); }

			DebugLocation(566, 2);
			Match(input,COMMA,Follow._COMMA_in_expressionFuncOldStyle2973); if (state.failed) return value;
			DebugLocation(566, 8);
			PushFollow(Follow._expressionFuncArgs_in_expressionFuncOldStyle2975);
			expressionFuncArgs(args);
			PopFollow();
			if (state.failed) return value;
			DebugLocation(566, 33);
			Match(input,RPARENTH,Follow._RPARENTH_in_expressionFuncOldStyle2978); if (state.failed) return value;
			DebugLocation(566, 42);
			if (state.backtracking == 0)
			{
				value = new FuncNary(s, args);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionFuncOldStyle", 44);
			LeaveRule("expressionFuncOldStyle", 44);
			LeaveRule_expressionFuncOldStyle();
		}
		DebugLocation(567, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionFuncOldStyle"); }
		return value;

	}
	// $ANTLR end "expressionFuncOldStyle"

	partial void EnterRule_eqNeq();
	partial void LeaveRule_eqNeq();

	// $ANTLR start "eqNeq"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:569:1: eqNeq returns [string value] : ( EQ | NE );
	[GrammarRule("eqNeq")]
	private string eqNeq()
	{
		EnterRule_eqNeq();
		EnterRule("eqNeq", 45);
		TraceIn("eqNeq", 45);
		string value = default(string);



			

		try { DebugEnterRule(GrammarFileName, "eqNeq");
		DebugLocation(569, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:573:2: ( EQ | NE )
			int alt52=2;
			try { DebugEnterDecision(52, false);
			int LA52_0 = input.LA(1);

			if ((LA52_0==EQ))
			{
				alt52 = 1;
			}
			else if ((LA52_0==NE))
			{
				alt52 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 52, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:573:4: EQ
				{
				DebugLocation(573, 4);
				Match(input,EQ,Follow._EQ_in_eqNeq2999); if (state.failed) return value;
				DebugLocation(573, 6);
				if (state.backtracking == 0)
				{
					value = PrimitiveApplication.EQUAL;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:574:4: NE
				{
				DebugLocation(574, 4);
				Match(input,NE,Follow._NE_in_eqNeq3005); if (state.failed) return value;
				DebugLocation(574, 6);
				if (state.backtracking == 0)
				{
					value = PrimitiveApplication.NOT_EQUAL;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("eqNeq", 45);
			LeaveRule("eqNeq", 45);
			LeaveRule_eqNeq();
		}
		DebugLocation(575, 0);
		} finally { DebugExitRule(GrammarFileName, "eqNeq"); }
		return value;

	}
	// $ANTLR end "eqNeq"

	private sealed partial class ltGt_return : ParserRuleReturnScope<IToken>
	{
		public string value;
		public ltGt_return(PrismModelParser grammar) {OnCreated(grammar);}
		partial void OnCreated(PrismModelParser grammar);
	}

	partial void EnterRule_ltGt();
	partial void LeaveRule_ltGt();

	// $ANTLR start "ltGt"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:577:1: ltGt returns [string value] : ( GT | LT | GE | LE );
	[GrammarRule("ltGt")]
	private PrismModelParser.ltGt_return ltGt()
	{
		EnterRule_ltGt();
		EnterRule("ltGt", 46);
		TraceIn("ltGt", 46);
		PrismModelParser.ltGt_return retval = new PrismModelParser.ltGt_return(this);
		retval.Start = (IToken)input.LT(1);


			

		try { DebugEnterRule(GrammarFileName, "ltGt");
		DebugLocation(577, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:581:2: ( GT | LT | GE | LE )
			int alt53=4;
			try { DebugEnterDecision(53, false);
			switch (input.LA(1))
			{
			case GT:
				{
				alt53 = 1;
				}
				break;
			case LT:
				{
				alt53 = 2;
				}
				break;
			case GE:
				{
				alt53 = 3;
				}
				break;
			case LE:
				{
				alt53 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 53, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:581:4: GT
				{
				DebugLocation(581, 4);
				Match(input,GT,Follow._GT_in_ltGt3024); if (state.failed) return retval;
				DebugLocation(581, 6);
				if (state.backtracking == 0)
				{
					retval.value = PrimitiveApplication.GREATER;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:582:4: LT
				{
				DebugLocation(582, 4);
				Match(input,LT,Follow._LT_in_ltGt3030); if (state.failed) return retval;
				DebugLocation(582, 6);
				if (state.backtracking == 0)
				{
					retval.value = PrimitiveApplication.LESS;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:583:4: GE
				{
				DebugLocation(583, 4);
				Match(input,GE,Follow._GE_in_ltGt3036); if (state.failed) return retval;
				DebugLocation(583, 6);
				if (state.backtracking == 0)
				{
					retval.value = PrimitiveApplication.GREATER_EQUAL;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:584:4: LE
				{
				DebugLocation(584, 4);
				Match(input,LE,Follow._LE_in_ltGt3042); if (state.failed) return retval;
				DebugLocation(584, 6);
				if (state.backtracking == 0)
				{
					retval.value = PrimitiveApplication.LESS_EQUAL;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ltGt", 46);
			LeaveRule("ltGt", 46);
			LeaveRule_ltGt();
		}
		DebugLocation(585, 0);
		} finally { DebugExitRule(GrammarFileName, "ltGt"); }
		return retval;

	}
	// $ANTLR end "ltGt"

	partial void EnterRule_expressionProb();
	partial void LeaveRule_expressionProb();

	// $ANTLR start "expressionProb"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:589:1: expressionProb returns [Expression value] : ( P ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK ) | PMIN EQ QMARK | PMAX EQ QMARK ) LBRACKET expr= expression ( filter )? RBRACKET ;
	[GrammarRule("expressionProb")]
	private Expression expressionProb()
	{
		EnterRule_expressionProb();
		EnterRule("expressionProb", 47);
		TraceIn("expressionProb", 47);
		Expression value = default(Expression);


		Expression prob = default(Expression);
		Expression expr = default(Expression);
		PrismModelParser.ltGt_return ltGt48 = default(PrismModelParser.ltGt_return);
		OldStyleFilter filter49 = default(OldStyleFilter);


			string relOp = null;
			bool isBool = false;
			OldStyleFilter f = null;

		try { DebugEnterRule(GrammarFileName, "expressionProb");
		DebugLocation(589, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:595:2: ( ( P ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK ) | PMIN EQ QMARK | PMAX EQ QMARK ) LBRACKET expr= expression ( filter )? RBRACKET )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:595:3: ( P ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK ) | PMIN EQ QMARK | PMAX EQ QMARK ) LBRACKET expr= expression ( filter )? RBRACKET
			{
			DebugLocation(595, 3);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:595:3: ( P ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK ) | PMIN EQ QMARK | PMAX EQ QMARK )
			int alt55=3;
			try { DebugEnterSubRule(55);
			try { DebugEnterDecision(55, false);
			switch (input.LA(1))
			{
			case P:
				{
				alt55 = 1;
				}
				break;
			case PMIN:
				{
				alt55 = 2;
				}
				break;
			case PMAX:
				{
				alt55 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 55, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:595:5: P ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK )
				{
				DebugLocation(595, 5);
				Match(input,P,Follow._P_in_expressionProb3064); if (state.failed) return value;
				DebugLocation(596, 2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:596:2: ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK )
				int alt54=4;
				try { DebugEnterSubRule(54);
				try { DebugEnterDecision(54, false);
				switch (input.LA(1))
				{
				case GE:
				case GT:
				case LE:
				case LT:
					{
					alt54 = 1;
					}
					break;
				case EQ:
					{
					alt54 = 2;
					}
					break;
				case MIN:
					{
					alt54 = 3;
					}
					break;
				case MAX:
					{
					alt54 = 4;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 54, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(54); }
				switch (alt54)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:596:3: ltGt prob= expression
					{
					DebugLocation(596, 3);
					PushFollow(Follow._ltGt_in_expressionProb3069);
					ltGt48=ltGt();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(596, 13);
					PushFollow(Follow._expression_in_expressionProb3075);
					prob=expression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(596, 25);
					if (state.backtracking == 0)
					{
						relOp = (ltGt48!=null?input.ToString(ltGt48.Start,ltGt48.Stop):null); isBool = true;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:597:4: EQ QMARK
					{
					DebugLocation(597, 4);
					Match(input,EQ,Follow._EQ_in_expressionProb3081); if (state.failed) return value;
					DebugLocation(597, 7);
					Match(input,QMARK,Follow._QMARK_in_expressionProb3083); if (state.failed) return value;
					DebugLocation(597, 12);
					if (state.backtracking == 0)
					{
						relOp = PrimitiveApplication.EQUAL; isBool = false;
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:598:4: MIN EQ QMARK
					{
					DebugLocation(598, 4);
					Match(input,MIN,Follow._MIN_in_expressionProb3089); if (state.failed) return value;
					DebugLocation(598, 8);
					Match(input,EQ,Follow._EQ_in_expressionProb3091); if (state.failed) return value;
					DebugLocation(598, 11);
					Match(input,QMARK,Follow._QMARK_in_expressionProb3093); if (state.failed) return value;
					DebugLocation(598, 16);
					if (state.backtracking == 0)
					{
						relOp = PrimitiveApplication.MIN; isBool = false;
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:599:4: MAX EQ QMARK
					{
					DebugLocation(599, 4);
					Match(input,MAX,Follow._MAX_in_expressionProb3099); if (state.failed) return value;
					DebugLocation(599, 8);
					Match(input,EQ,Follow._EQ_in_expressionProb3101); if (state.failed) return value;
					DebugLocation(599, 11);
					Match(input,QMARK,Follow._QMARK_in_expressionProb3103); if (state.failed) return value;
					DebugLocation(599, 16);
					if (state.backtracking == 0)
					{
						relOp = PrimitiveApplication.MAX; isBool = false;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(54); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:601:4: PMIN EQ QMARK
				{
				DebugLocation(601, 4);
				Match(input,PMIN,Follow._PMIN_in_expressionProb3112); if (state.failed) return value;
				DebugLocation(601, 9);
				Match(input,EQ,Follow._EQ_in_expressionProb3114); if (state.failed) return value;
				DebugLocation(601, 12);
				Match(input,QMARK,Follow._QMARK_in_expressionProb3116); if (state.failed) return value;
				DebugLocation(601, 17);
				if (state.backtracking == 0)
				{
					relOp = PrimitiveApplication.MIN; isBool = false;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:602:4: PMAX EQ QMARK
				{
				DebugLocation(602, 4);
				Match(input,PMAX,Follow._PMAX_in_expressionProb3122); if (state.failed) return value;
				DebugLocation(602, 9);
				Match(input,EQ,Follow._EQ_in_expressionProb3124); if (state.failed) return value;
				DebugLocation(602, 12);
				Match(input,QMARK,Follow._QMARK_in_expressionProb3126); if (state.failed) return value;
				DebugLocation(602, 17);
				if (state.backtracking == 0)
				{
					relOp = PrimitiveApplication.MAX; isBool = false;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(55); }

			DebugLocation(604, 2);
			Match(input,LBRACKET,Follow._LBRACKET_in_expressionProb3133); if (state.failed) return value;
			DebugLocation(604, 16);
			PushFollow(Follow._expression_in_expressionProb3139);
			expr=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(604, 29);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:604:29: ( filter )?
			int alt56=2;
			try { DebugEnterSubRule(56);
			try { DebugEnterDecision(56, false);
			int LA56_0 = input.LA(1);

			if ((LA56_0==LBRACE))
			{
				alt56 = 1;
			}
			} finally { DebugExitDecision(56); }
			switch (alt56)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:604:30: filter
				{
				DebugLocation(604, 30);
				PushFollow(Follow._filter_in_expressionProb3142);
				filter49=filter();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(604, 36);
				if (state.backtracking == 0)
				{
					f = filter49;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(56); }

			DebugLocation(605, 2);
			Match(input,RBRACKET,Follow._RBRACKET_in_expressionProb3148); if (state.failed) return value;
			DebugLocation(605, 10);
			if (state.backtracking == 0)
			{
				value = new ProbQuery(expr, relOp, prob); 
							if (f != null) {
							string filterOp = isBool ? "&" : f.getFilterOpString();
							value = new NewStyleFilter(filterOp, value, f.expr);
						    }
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionProb", 47);
			LeaveRule("expressionProb", 47);
			LeaveRule_expressionProb();
		}
		DebugLocation(611, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionProb"); }
		return value;

	}
	// $ANTLR end "expressionProb"

	partial void EnterRule_filter();
	partial void LeaveRule_filter();

	// $ANTLR start "filter"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:614:1: filter returns [OldStyleFilter value] : LBRACE expr= expression RBRACE ( LBRACE ( MIN | MAX ) RBRACE )* ;
	[GrammarRule("filter")]
	private OldStyleFilter filter()
	{
		EnterRule_filter();
		EnterRule("filter", 48);
		TraceIn("filter", 48);
		OldStyleFilter value = default(OldStyleFilter);


		Expression expr = default(Expression);


			

		try { DebugEnterRule(GrammarFileName, "filter");
		DebugLocation(614, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:618:2: ( LBRACE expr= expression RBRACE ( LBRACE ( MIN | MAX ) RBRACE )* )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:618:4: LBRACE expr= expression RBRACE ( LBRACE ( MIN | MAX ) RBRACE )*
			{
			DebugLocation(618, 4);
			Match(input,LBRACE,Follow._LBRACE_in_filter3168); if (state.failed) return value;
			DebugLocation(618, 16);
			PushFollow(Follow._expression_in_filter3174);
			expr=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(618, 28);
			if (state.backtracking == 0)
			{
				value = new OldStyleFilter(expr);
			}
			DebugLocation(618, 64);
			Match(input,RBRACE,Follow._RBRACE_in_filter3177); if (state.failed) return value;
			DebugLocation(619, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:619:2: ( LBRACE ( MIN | MAX ) RBRACE )*
			try { DebugEnterSubRule(58);
			while (true)
			{
				int alt58=2;
				try { DebugEnterDecision(58, false);
				int LA58_0 = input.LA(1);

				if ((LA58_0==LBRACE))
				{
					alt58 = 1;
				}


				} finally { DebugExitDecision(58); }
				switch ( alt58 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:619:3: LBRACE ( MIN | MAX ) RBRACE
					{
					DebugLocation(619, 3);
					Match(input,LBRACE,Follow._LBRACE_in_filter3181); if (state.failed) return value;
					DebugLocation(620, 3);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:620:3: ( MIN | MAX )
					int alt57=2;
					try { DebugEnterSubRule(57);
					try { DebugEnterDecision(57, false);
					int LA57_0 = input.LA(1);

					if ((LA57_0==MIN))
					{
						alt57 = 1;
					}
					else if ((LA57_0==MAX))
					{
						alt57 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 57, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(57); }
					switch (alt57)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:620:5: MIN
						{
						DebugLocation(620, 5);
						Match(input,MIN,Follow._MIN_in_filter3187); if (state.failed) return value;
						DebugLocation(620, 8);
						if (state.backtracking == 0)
						{
							value.minReq = true;
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:621:4: MAX
						{
						DebugLocation(621, 4);
						Match(input,MAX,Follow._MAX_in_filter3193); if (state.failed) return value;
						DebugLocation(621, 7);
						if (state.backtracking == 0)
						{
							value.maxReq = true;
						}

						}
						break;

					}
					} finally { DebugExitSubRule(57); }

					DebugLocation(623, 2);
					Match(input,RBRACE,Follow._RBRACE_in_filter3201); if (state.failed) return value;

					}
					break;

				default:
					goto loop58;
				}
			}

			loop58:
				;

			} finally { DebugExitSubRule(58); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("filter", 48);
			LeaveRule("filter", 48);
			LeaveRule_filter();
		}
		DebugLocation(624, 0);
		} finally { DebugExitRule(GrammarFileName, "filter"); }
		return value;

	}
	// $ANTLR end "filter"

	partial void EnterRule_expressionSS();
	partial void LeaveRule_expressionSS();

	// $ANTLR start "expressionSS"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:627:1: expressionSS returns [Expression value] : S ( ltGt prob= expression | EQ QMARK ) LBRACKET expr= expression ( filter )? RBRACKET ;
	[GrammarRule("expressionSS")]
	private Expression expressionSS()
	{
		EnterRule_expressionSS();
		EnterRule("expressionSS", 49);
		TraceIn("expressionSS", 49);
		Expression value = default(Expression);


		Expression prob = default(Expression);
		Expression expr = default(Expression);
		PrismModelParser.ltGt_return ltGt50 = default(PrismModelParser.ltGt_return);
		OldStyleFilter filter51 = default(OldStyleFilter);


			string relOp = null;
			bool isBool = false;
			OldStyleFilter f = null;

		try { DebugEnterRule(GrammarFileName, "expressionSS");
		DebugLocation(627, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:633:2: ( S ( ltGt prob= expression | EQ QMARK ) LBRACKET expr= expression ( filter )? RBRACKET )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:633:4: S ( ltGt prob= expression | EQ QMARK ) LBRACKET expr= expression ( filter )? RBRACKET
			{
			DebugLocation(633, 4);
			Match(input,S,Follow._S_in_expressionSS3222); if (state.failed) return value;
			DebugLocation(634, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:634:2: ( ltGt prob= expression | EQ QMARK )
			int alt59=2;
			try { DebugEnterSubRule(59);
			try { DebugEnterDecision(59, false);
			int LA59_0 = input.LA(1);

			if ((LA59_0==GE||LA59_0==GT||LA59_0==LE||LA59_0==LT))
			{
				alt59 = 1;
			}
			else if ((LA59_0==EQ))
			{
				alt59 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 59, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:635:3: ltGt prob= expression
				{
				DebugLocation(635, 3);
				PushFollow(Follow._ltGt_in_expressionSS3230);
				ltGt50=ltGt();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(635, 13);
				PushFollow(Follow._expression_in_expressionSS3236);
				prob=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(635, 25);
				if (state.backtracking == 0)
				{
					relOp = (ltGt50!=null?input.ToString(ltGt50.Start,ltGt50.Stop):null); isBool = true;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:636:3: EQ QMARK
				{
				DebugLocation(636, 3);
				Match(input,EQ,Follow._EQ_in_expressionSS3241); if (state.failed) return value;
				DebugLocation(636, 6);
				Match(input,QMARK,Follow._QMARK_in_expressionSS3243); if (state.failed) return value;
				DebugLocation(636, 11);
				if (state.backtracking == 0)
				{
					relOp = PrimitiveApplication.EQUAL; isBool = false;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(59); }

			DebugLocation(638, 2);
			Match(input,LBRACKET,Follow._LBRACKET_in_expressionSS3252); if (state.failed) return value;
			DebugLocation(638, 16);
			PushFollow(Follow._expression_in_expressionSS3258);
			expr=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(638, 29);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:638:29: ( filter )?
			int alt60=2;
			try { DebugEnterSubRule(60);
			try { DebugEnterDecision(60, false);
			int LA60_0 = input.LA(1);

			if ((LA60_0==LBRACE))
			{
				alt60 = 1;
			}
			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:638:30: filter
				{
				DebugLocation(638, 30);
				PushFollow(Follow._filter_in_expressionSS3261);
				filter51=filter();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(638, 36);
				if (state.backtracking == 0)
				{
					f = filter51;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(60); }

			DebugLocation(639, 2);
			Match(input,RBRACKET,Follow._RBRACKET_in_expressionSS3267); if (state.failed) return value;
			DebugLocation(639, 10);
			if (state.backtracking == 0)
			{
				value = new SteadyState(expr, relOp, prob); 
							if (f != null) {
							string filterOp = isBool ? "&" : f.getFilterOpString();
							value = new NewStyleFilter(filterOp, value, f.expr);
						    }
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionSS", 49);
			LeaveRule("expressionSS", 49);
			LeaveRule_expressionSS();
		}
		DebugLocation(645, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionSS"); }
		return value;

	}
	// $ANTLR end "expressionSS"

	partial void EnterRule_expressionReward();
	partial void LeaveRule_expressionReward();

	// $ANTLR start "expressionReward"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:647:1: expressionReward returns [Expression value] : ( R ( rewardIndex[out rewardStructIndex, out rewardName] )? ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK ) | RMIN EQ QMARK | RMAX EQ QMARK ) LBRACKET expr= expressionRewardContents ( filter )? RBRACKET ;
	[GrammarRule("expressionReward")]
	private Expression expressionReward()
	{
		EnterRule_expressionReward();
		EnterRule("expressionReward", 50);
		TraceIn("expressionReward", 50);
		Expression value = default(Expression);


		Expression prob = default(Expression);
		Expression expr = default(Expression);
		PrismModelParser.ltGt_return ltGt52 = default(PrismModelParser.ltGt_return);
		OldStyleFilter filter53 = default(OldStyleFilter);


			int rewardStructIndex = -1;
		        string rewardName = null;
			
			string relOp = null;
			bool isBool = false;
			OldStyleFilter f = null;

		try { DebugEnterRule(GrammarFileName, "expressionReward");
		DebugLocation(647, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:656:2: ( ( R ( rewardIndex[out rewardStructIndex, out rewardName] )? ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK ) | RMIN EQ QMARK | RMAX EQ QMARK ) LBRACKET expr= expressionRewardContents ( filter )? RBRACKET )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:656:3: ( R ( rewardIndex[out rewardStructIndex, out rewardName] )? ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK ) | RMIN EQ QMARK | RMAX EQ QMARK ) LBRACKET expr= expressionRewardContents ( filter )? RBRACKET
			{
			DebugLocation(656, 3);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:656:3: ( R ( rewardIndex[out rewardStructIndex, out rewardName] )? ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK ) | RMIN EQ QMARK | RMAX EQ QMARK )
			int alt63=3;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			switch (input.LA(1))
			{
			case R:
				{
				alt63 = 1;
				}
				break;
			case RMIN:
				{
				alt63 = 2;
				}
				break;
			case RMAX:
				{
				alt63 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 63, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:656:5: R ( rewardIndex[out rewardStructIndex, out rewardName] )? ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK )
				{
				DebugLocation(656, 5);
				Match(input,R,Follow._R_in_expressionReward3287); if (state.failed) return value;
				DebugLocation(656, 7);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:656:7: ( rewardIndex[out rewardStructIndex, out rewardName] )?
				int alt61=2;
				try { DebugEnterSubRule(61);
				try { DebugEnterDecision(61, false);
				int LA61_0 = input.LA(1);

				if ((LA61_0==LBRACE))
				{
					alt61 = 1;
				}
				} finally { DebugExitDecision(61); }
				switch (alt61)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:656:8: rewardIndex[out rewardStructIndex, out rewardName]
					{
					DebugLocation(656, 8);
					PushFollow(Follow._rewardIndex_in_expressionReward3290);
					rewardIndex(out rewardStructIndex, out rewardName);
					PopFollow();
					if (state.failed) return value;

					}
					break;

				}
				} finally { DebugExitSubRule(61); }

				DebugLocation(657, 2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:657:2: ( ltGt prob= expression | EQ QMARK | MIN EQ QMARK | MAX EQ QMARK )
				int alt62=4;
				try { DebugEnterSubRule(62);
				try { DebugEnterDecision(62, false);
				switch (input.LA(1))
				{
				case GE:
				case GT:
				case LE:
				case LT:
					{
					alt62 = 1;
					}
					break;
				case EQ:
					{
					alt62 = 2;
					}
					break;
				case MIN:
					{
					alt62 = 3;
					}
					break;
				case MAX:
					{
					alt62 = 4;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return value;}
						NoViableAltException nvae = new NoViableAltException("", 62, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(62); }
				switch (alt62)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:657:3: ltGt prob= expression
					{
					DebugLocation(657, 3);
					PushFollow(Follow._ltGt_in_expressionReward3297);
					ltGt52=ltGt();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(657, 13);
					PushFollow(Follow._expression_in_expressionReward3303);
					prob=expression();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(657, 25);
					if (state.backtracking == 0)
					{
						relOp = (ltGt52!=null?input.ToString(ltGt52.Start,ltGt52.Stop):null); isBool = true;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:658:4: EQ QMARK
					{
					DebugLocation(658, 4);
					Match(input,EQ,Follow._EQ_in_expressionReward3309); if (state.failed) return value;
					DebugLocation(658, 7);
					Match(input,QMARK,Follow._QMARK_in_expressionReward3311); if (state.failed) return value;
					DebugLocation(658, 12);
					if (state.backtracking == 0)
					{
						relOp = PrimitiveApplication.EQUAL; isBool = false;
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:659:4: MIN EQ QMARK
					{
					DebugLocation(659, 4);
					Match(input,MIN,Follow._MIN_in_expressionReward3317); if (state.failed) return value;
					DebugLocation(659, 8);
					Match(input,EQ,Follow._EQ_in_expressionReward3319); if (state.failed) return value;
					DebugLocation(659, 11);
					Match(input,QMARK,Follow._QMARK_in_expressionReward3321); if (state.failed) return value;
					DebugLocation(659, 16);
					if (state.backtracking == 0)
					{
						relOp = PrimitiveApplication.MIN; isBool = false;
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:660:4: MAX EQ QMARK
					{
					DebugLocation(660, 4);
					Match(input,MAX,Follow._MAX_in_expressionReward3327); if (state.failed) return value;
					DebugLocation(660, 8);
					Match(input,EQ,Follow._EQ_in_expressionReward3329); if (state.failed) return value;
					DebugLocation(660, 11);
					Match(input,QMARK,Follow._QMARK_in_expressionReward3331); if (state.failed) return value;
					DebugLocation(660, 16);
					if (state.backtracking == 0)
					{
						relOp = PrimitiveApplication.MAX; isBool = false;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(62); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:662:4: RMIN EQ QMARK
				{
				DebugLocation(662, 4);
				Match(input,RMIN,Follow._RMIN_in_expressionReward3340); if (state.failed) return value;
				DebugLocation(662, 9);
				Match(input,EQ,Follow._EQ_in_expressionReward3342); if (state.failed) return value;
				DebugLocation(662, 12);
				Match(input,QMARK,Follow._QMARK_in_expressionReward3344); if (state.failed) return value;
				DebugLocation(662, 17);
				if (state.backtracking == 0)
				{
					relOp = PrimitiveApplication.MIN; isBool = false;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:663:4: RMAX EQ QMARK
				{
				DebugLocation(663, 4);
				Match(input,RMAX,Follow._RMAX_in_expressionReward3350); if (state.failed) return value;
				DebugLocation(663, 9);
				Match(input,EQ,Follow._EQ_in_expressionReward3352); if (state.failed) return value;
				DebugLocation(663, 12);
				Match(input,QMARK,Follow._QMARK_in_expressionReward3354); if (state.failed) return value;
				DebugLocation(663, 17);
				if (state.backtracking == 0)
				{
					relOp = PrimitiveApplication.MAX; isBool = false;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(63); }

			DebugLocation(665, 2);
			Match(input,LBRACKET,Follow._LBRACKET_in_expressionReward3361); if (state.failed) return value;
			DebugLocation(665, 16);
			PushFollow(Follow._expressionRewardContents_in_expressionReward3367);
			expr=expressionRewardContents();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(665, 43);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:665:43: ( filter )?
			int alt64=2;
			try { DebugEnterSubRule(64);
			try { DebugEnterDecision(64, false);
			int LA64_0 = input.LA(1);

			if ((LA64_0==LBRACE))
			{
				alt64 = 1;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:665:44: filter
				{
				DebugLocation(665, 44);
				PushFollow(Follow._filter_in_expressionReward3370);
				filter53=filter();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(665, 50);
				if (state.backtracking == 0)
				{
					f = filter53;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(64); }

			DebugLocation(666, 2);
			Match(input,RBRACKET,Follow._RBRACKET_in_expressionReward3376); if (state.failed) return value;
			DebugLocation(666, 10);
			if (state.backtracking == 0)
			{
				value = new RewardQuery(expr, relOp, prob, rewardStructIndex, rewardName);
							if (f != null) {
							string filterOp = isBool ? "&" : f.getFilterOpString();
							value = new NewStyleFilter(filterOp, value, f.expr);
						    }
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionReward", 50);
			LeaveRule("expressionReward", 50);
			LeaveRule_expressionReward();
		}
		DebugLocation(672, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionReward"); }
		return value;

	}
	// $ANTLR end "expressionReward"

	partial void EnterRule_rewardIndex();
	partial void LeaveRule_rewardIndex();

	// $ANTLR start "rewardIndex"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:675:1: rewardIndex[out int rewardIndex, out string rewardName] : LBRACE ( DQUOTE ID DQUOTE | INT_NUM ) RBRACE ;
	[GrammarRule("rewardIndex")]
	private void rewardIndex(out int rewardIndex, out string rewardName)
	{
		EnterRule_rewardIndex();
		EnterRule("rewardIndex", 51);
		TraceIn("rewardIndex", 51);
		IToken ID54 = default(IToken);
		IToken INT_NUM55 = default(IToken);


			rewardIndex = -1;
		        rewardName = null;

		try { DebugEnterRule(GrammarFileName, "rewardIndex");
		DebugLocation(675, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:680:2: ( LBRACE ( DQUOTE ID DQUOTE | INT_NUM ) RBRACE )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:680:4: LBRACE ( DQUOTE ID DQUOTE | INT_NUM ) RBRACE
			{
			DebugLocation(680, 4);
			Match(input,LBRACE,Follow._LBRACE_in_rewardIndex3394); if (state.failed) return;
			DebugLocation(681, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:681:2: ( DQUOTE ID DQUOTE | INT_NUM )
			int alt65=2;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, false);
			int LA65_0 = input.LA(1);

			if ((LA65_0==DQUOTE))
			{
				alt65 = 1;
			}
			else if ((LA65_0==INT_NUM))
			{
				alt65 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 65, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:681:3: DQUOTE ID DQUOTE
				{
				DebugLocation(681, 3);
				Match(input,DQUOTE,Follow._DQUOTE_in_rewardIndex3398); if (state.failed) return;
				DebugLocation(681, 10);
				ID54=(IToken)Match(input,ID,Follow._ID_in_rewardIndex3400); if (state.failed) return;
				DebugLocation(681, 12);
				if (state.backtracking == 0)
				{
					rewardName = (ID54!=null?ID54.Text:null);
				}
				DebugLocation(681, 37);
				Match(input,DQUOTE,Follow._DQUOTE_in_rewardIndex3403); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:682:4: INT_NUM
				{
				DebugLocation(682, 4);
				INT_NUM55=(IToken)Match(input,INT_NUM,Follow._INT_NUM_in_rewardIndex3408); if (state.failed) return;
				DebugLocation(682, 11);
				if (state.backtracking == 0)
				{
					rewardIndex = int.Parse((INT_NUM55!=null?INT_NUM55.Text:null));
				}

				}
				break;

			}
			} finally { DebugExitSubRule(65); }

			DebugLocation(684, 2);
			Match(input,RBRACE,Follow._RBRACE_in_rewardIndex3415); if (state.failed) return;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewardIndex", 51);
			LeaveRule("rewardIndex", 51);
			LeaveRule_rewardIndex();
		}
		DebugLocation(686, 0);
		} finally { DebugExitRule(GrammarFileName, "rewardIndex"); }
		return;

	}
	// $ANTLR end "rewardIndex"

	partial void EnterRule_expressionRewardContents();
	partial void LeaveRule_expressionRewardContents();

	// $ANTLR start "expressionRewardContents"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:689:1: expressionRewardContents returns [Expression value] : ( C LE exprC= expression | I EQ exprI= expression | F exprF= expression | S ) ;
	[GrammarRule("expressionRewardContents")]
	private Expression expressionRewardContents()
	{
		EnterRule_expressionRewardContents();
		EnterRule("expressionRewardContents", 52);
		TraceIn("expressionRewardContents", 52);
		Expression value = default(Expression);


		Expression exprC = default(Expression);
		Expression exprI = default(Expression);
		Expression exprF = default(Expression);


			Temporal ret = new Temporal();

		try { DebugEnterRule(GrammarFileName, "expressionRewardContents");
		DebugLocation(689, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:693:2: ( ( C LE exprC= expression | I EQ exprI= expression | F exprF= expression | S ) )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:693:4: ( C LE exprC= expression | I EQ exprI= expression | F exprF= expression | S )
			{
			DebugLocation(693, 4);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:693:4: ( C LE exprC= expression | I EQ exprI= expression | F exprF= expression | S )
			int alt66=4;
			try { DebugEnterSubRule(66);
			try { DebugEnterDecision(66, false);
			switch (input.LA(1))
			{
			case C:
				{
				alt66 = 1;
				}
				break;
			case I:
				{
				alt66 = 2;
				}
				break;
			case F:
				{
				alt66 = 3;
				}
				break;
			case S:
				{
				alt66 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 66, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:693:5: C LE exprC= expression
				{
				DebugLocation(693, 5);
				Match(input,C,Follow._C_in_expressionRewardContents3438); if (state.failed) return value;
				DebugLocation(693, 7);
				Match(input,LE,Follow._LE_in_expressionRewardContents3440); if (state.failed) return value;
				DebugLocation(693, 16);
				PushFollow(Follow._expression_in_expressionRewardContents3446);
				exprC=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(693, 28);
				if (state.backtracking == 0)
				{
					ret.op = TemporalOpt.Cummulative; ret.uBound = exprC;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:694:4: I EQ exprI= expression
				{
				DebugLocation(694, 4);
				Match(input,I,Follow._I_in_expressionRewardContents3452); if (state.failed) return value;
				DebugLocation(694, 6);
				Match(input,EQ,Follow._EQ_in_expressionRewardContents3454); if (state.failed) return value;
				DebugLocation(694, 15);
				PushFollow(Follow._expression_in_expressionRewardContents3460);
				exprI=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(694, 27);
				if (state.backtracking == 0)
				{
					ret.op = TemporalOpt.Instantaneous; ret.uBound = exprI;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:695:4: F exprF= expression
				{
				DebugLocation(695, 4);
				Match(input,F,Follow._F_in_expressionRewardContents3466); if (state.failed) return value;
				DebugLocation(695, 12);
				PushFollow(Follow._expression_in_expressionRewardContents3472);
				exprF=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(695, 24);
				if (state.backtracking == 0)
				{
					ret.op = TemporalOpt.Reachability; ret.operand2 = exprF;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:696:4: S
				{
				DebugLocation(696, 4);
				Match(input,S,Follow._S_in_expressionRewardContents3478); if (state.failed) return value;
				DebugLocation(696, 6);
				if (state.backtracking == 0)
				{
					ret.op = TemporalOpt.SteadyState;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(66); }

			DebugLocation(697, 3);
			if (state.backtracking == 0)
			{
				value = ret;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionRewardContents", 52);
			LeaveRule("expressionRewardContents", 52);
			LeaveRule_expressionRewardContents();
		}
		DebugLocation(700, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionRewardContents"); }
		return value;

	}
	// $ANTLR end "expressionRewardContents"

	partial void EnterRule_expressionExists();
	partial void LeaveRule_expressionExists();

	// $ANTLR start "expressionExists"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:703:1: expressionExists returns [Expression value] : E LBRACKET expr= expression RBRACKET ;
	[GrammarRule("expressionExists")]
	private Expression expressionExists()
	{
		EnterRule_expressionExists();
		EnterRule("expressionExists", 53);
		TraceIn("expressionExists", 53);
		Expression value = default(Expression);


		Expression expr = default(Expression);




		try { DebugEnterRule(GrammarFileName, "expressionExists");
		DebugLocation(703, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:707:2: ( E LBRACKET expr= expression RBRACKET )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:707:4: E LBRACKET expr= expression RBRACKET
			{
			DebugLocation(707, 4);
			Match(input,E,Follow._E_in_expressionExists3508); if (state.failed) return value;
			DebugLocation(707, 6);
			Match(input,LBRACKET,Follow._LBRACKET_in_expressionExists3510); if (state.failed) return value;
			DebugLocation(707, 20);
			PushFollow(Follow._expression_in_expressionExists3516);
			expr=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(707, 33);
			Match(input,RBRACKET,Follow._RBRACKET_in_expressionExists3518); if (state.failed) return value;
			DebugLocation(707, 41);
			if (state.backtracking == 0)
			{
				value = new Exists(expr);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionExists", 53);
			LeaveRule("expressionExists", 53);
			LeaveRule_expressionExists();
		}
		DebugLocation(710, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionExists"); }
		return value;

	}
	// $ANTLR end "expressionExists"

	partial void EnterRule_expressionForAll();
	partial void LeaveRule_expressionForAll();

	// $ANTLR start "expressionForAll"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:712:1: expressionForAll returns [Expression value] : A LBRACKET expr= expression RBRACKET ;
	[GrammarRule("expressionForAll")]
	private Expression expressionForAll()
	{
		EnterRule_expressionForAll();
		EnterRule("expressionForAll", 54);
		TraceIn("expressionForAll", 54);
		Expression value = default(Expression);


		Expression expr = default(Expression);




		try { DebugEnterRule(GrammarFileName, "expressionForAll");
		DebugLocation(712, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:716:2: ( A LBRACKET expr= expression RBRACKET )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:716:4: A LBRACKET expr= expression RBRACKET
			{
			DebugLocation(716, 4);
			Match(input,A,Follow._A_in_expressionForAll3542); if (state.failed) return value;
			DebugLocation(716, 6);
			Match(input,LBRACKET,Follow._LBRACKET_in_expressionForAll3544); if (state.failed) return value;
			DebugLocation(716, 20);
			PushFollow(Follow._expression_in_expressionForAll3550);
			expr=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(716, 33);
			Match(input,RBRACKET,Follow._RBRACKET_in_expressionForAll3552); if (state.failed) return value;
			DebugLocation(716, 41);
			if (state.backtracking == 0)
			{
				value = new ForAll(expr);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionForAll", 54);
			LeaveRule("expressionForAll", 54);
			LeaveRule_expressionForAll();
		}
		DebugLocation(719, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionForAll"); }
		return value;

	}
	// $ANTLR end "expressionForAll"

	partial void EnterRule_expressionLabel();
	partial void LeaveRule_expressionLabel();

	// $ANTLR start "expressionLabel"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:721:1: expressionLabel returns [Expression value] : DQUOTE ( ID | INIT ) DQUOTE ;
	[GrammarRule("expressionLabel")]
	private Expression expressionLabel()
	{
		EnterRule_expressionLabel();
		EnterRule("expressionLabel", 55);
		TraceIn("expressionLabel", 55);
		Expression value = default(Expression);


		IToken ID56 = default(IToken);


			string s = string.Empty;

		try { DebugEnterRule(GrammarFileName, "expressionLabel");
		DebugLocation(721, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:725:2: ( DQUOTE ( ID | INIT ) DQUOTE )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:725:4: DQUOTE ( ID | INIT ) DQUOTE
			{
			DebugLocation(725, 4);
			Match(input,DQUOTE,Follow._DQUOTE_in_expressionLabel3576); if (state.failed) return value;
			DebugLocation(725, 11);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:725:11: ( ID | INIT )
			int alt67=2;
			try { DebugEnterSubRule(67);
			try { DebugEnterDecision(67, false);
			int LA67_0 = input.LA(1);

			if ((LA67_0==ID))
			{
				alt67 = 1;
			}
			else if ((LA67_0==INIT))
			{
				alt67 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 67, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:725:12: ID
				{
				DebugLocation(725, 12);
				ID56=(IToken)Match(input,ID,Follow._ID_in_expressionLabel3579); if (state.failed) return value;
				DebugLocation(725, 14);
				if (state.backtracking == 0)
				{
					s = (ID56!=null?ID56.Text:null);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:725:32: INIT
				{
				DebugLocation(725, 32);
				Match(input,INIT,Follow._INIT_in_expressionLabel3584); if (state.failed) return value;
				DebugLocation(725, 37);
				if (state.backtracking == 0)
				{
					s = "init";
				}

				}
				break;

			}
			} finally { DebugExitSubRule(67); }

			DebugLocation(725, 52);
			Match(input,DQUOTE,Follow._DQUOTE_in_expressionLabel3589); if (state.failed) return value;
			DebugLocation(725, 58);
			if (state.backtracking == 0)
			{
				value = new Label(s);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionLabel", 55);
			LeaveRule("expressionLabel", 55);
			LeaveRule_expressionLabel();
		}
		DebugLocation(728, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionLabel"); }
		return value;

	}
	// $ANTLR end "expressionLabel"

	partial void EnterRule_expressionFilter();
	partial void LeaveRule_expressionFilter();

	// $ANTLR start "expressionFilter"
	// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:730:1: expressionFilter returns [Expression value] : FILTER LPARENTH ( MIN | MAX | PLUS | AND | OR | ID ) COMMA expr2= expression ( COMMA f= expression )? RPARENTH ;
	[GrammarRule("expressionFilter")]
	private Expression expressionFilter()
	{
		EnterRule_expressionFilter();
		EnterRule("expressionFilter", 56);
		TraceIn("expressionFilter", 56);
		Expression value = default(Expression);


		IToken ID57 = default(IToken);
		Expression expr2 = default(Expression);
		Expression f = default(Expression);


			string op = string.Empty;
			Expression filter = null;

		try { DebugEnterRule(GrammarFileName, "expressionFilter");
		DebugLocation(730, 0);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:735:2: ( FILTER LPARENTH ( MIN | MAX | PLUS | AND | OR | ID ) COMMA expr2= expression ( COMMA f= expression )? RPARENTH )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:735:4: FILTER LPARENTH ( MIN | MAX | PLUS | AND | OR | ID ) COMMA expr2= expression ( COMMA f= expression )? RPARENTH
			{
			DebugLocation(735, 4);
			Match(input,FILTER,Follow._FILTER_in_expressionFilter3613); if (state.failed) return value;
			DebugLocation(735, 11);
			Match(input,LPARENTH,Follow._LPARENTH_in_expressionFilter3615); if (state.failed) return value;
			DebugLocation(736, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:736:2: ( MIN | MAX | PLUS | AND | OR | ID )
			int alt68=6;
			try { DebugEnterSubRule(68);
			try { DebugEnterDecision(68, false);
			switch (input.LA(1))
			{
			case MIN:
				{
				alt68 = 1;
				}
				break;
			case MAX:
				{
				alt68 = 2;
				}
				break;
			case PLUS:
				{
				alt68 = 3;
				}
				break;
			case AND:
				{
				alt68 = 4;
				}
				break;
			case OR:
				{
				alt68 = 5;
				}
				break;
			case ID:
				{
				alt68 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 68, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:736:4: MIN
				{
				DebugLocation(736, 4);
				Match(input,MIN,Follow._MIN_in_expressionFilter3620); if (state.failed) return value;
				DebugLocation(736, 8);
				if (state.backtracking == 0)
				{
					 op = "min"; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:737:4: MAX
				{
				DebugLocation(737, 4);
				Match(input,MAX,Follow._MAX_in_expressionFilter3628); if (state.failed) return value;
				DebugLocation(737, 8);
				if (state.backtracking == 0)
				{
					 op = "max"; 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:738:4: PLUS
				{
				DebugLocation(738, 4);
				Match(input,PLUS,Follow._PLUS_in_expressionFilter3635); if (state.failed) return value;
				DebugLocation(738, 9);
				if (state.backtracking == 0)
				{
					 op = "+"; 
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:739:4: AND
				{
				DebugLocation(739, 4);
				Match(input,AND,Follow._AND_in_expressionFilter3642); if (state.failed) return value;
				DebugLocation(739, 8);
				if (state.backtracking == 0)
				{
					 op = "&"; 
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:740:4: OR
				{
				DebugLocation(740, 4);
				Match(input,OR,Follow._OR_in_expressionFilter3649); if (state.failed) return value;
				DebugLocation(740, 7);
				if (state.backtracking == 0)
				{
					 op = "|"; 
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:741:4: ID
				{
				DebugLocation(741, 4);
				ID57=(IToken)Match(input,ID,Follow._ID_in_expressionFilter3656); if (state.failed) return value;
				DebugLocation(741, 7);
				if (state.backtracking == 0)
				{
					 op = (ID57!=null?ID57.Text:null);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(68); }

			DebugLocation(743, 2);
			Match(input,COMMA,Follow._COMMA_in_expressionFilter3664); if (state.failed) return value;
			DebugLocation(743, 14);
			PushFollow(Follow._expression_in_expressionFilter3670);
			expr2=expression();
			PopFollow();
			if (state.failed) return value;
			DebugLocation(744, 2);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:744:2: ( COMMA f= expression )?
			int alt69=2;
			try { DebugEnterSubRule(69);
			try { DebugEnterDecision(69, false);
			int LA69_0 = input.LA(1);

			if ((LA69_0==COMMA))
			{
				alt69 = 1;
			}
			} finally { DebugExitDecision(69); }
			switch (alt69)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:744:3: COMMA f= expression
				{
				DebugLocation(744, 3);
				Match(input,COMMA,Follow._COMMA_in_expressionFilter3674); if (state.failed) return value;
				DebugLocation(744, 11);
				PushFollow(Follow._expression_in_expressionFilter3680);
				f=expression();
				PopFollow();
				if (state.failed) return value;
				DebugLocation(744, 23);
				if (state.backtracking == 0)
				{
					filter = f;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(69); }

			DebugLocation(745, 2);
			Match(input,RPARENTH,Follow._RPARENTH_in_expressionFilter3686); if (state.failed) return value;
			DebugLocation(745, 10);
			if (state.backtracking == 0)
			{
				value = new NewStyleFilter(op, expr2, filter);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionFilter", 56);
			LeaveRule("expressionFilter", 56);
			LeaveRule_expressionFilter();
		}
		DebugLocation(746, 0);
		} finally { DebugExitRule(GrammarFileName, "expressionFilter"); }
		return value;

	}
	// $ANTLR end "expressionFilter"

	partial void EnterRule_synpred1_PrismModel_fragment();
	partial void LeaveRule_synpred1_PrismModel_fragment();

	// $ANTLR start synpred1_PrismModel
	public void synpred1_PrismModel_fragment()
	{
		EnterRule_synpred1_PrismModel_fragment();
		EnterRule("synpred1_PrismModel_fragment", 57);
		TraceIn("synpred1_PrismModel_fragment", 57);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:156:5: ( properties )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:156:5: properties
			{
			DebugLocation(156, 5);
			PushFollow(Follow._properties_in_synpred1_PrismModel1035);
			properties();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_PrismModel_fragment", 57);
			LeaveRule("synpred1_PrismModel_fragment", 57);
			LeaveRule_synpred1_PrismModel_fragment();
		}
	}
	// $ANTLR end synpred1_PrismModel

	partial void EnterRule_synpred2_PrismModel_fragment();
	partial void LeaveRule_synpred2_PrismModel_fragment();

	// $ANTLR start synpred2_PrismModel
	public void synpred2_PrismModel_fragment()
	{
		EnterRule_synpred2_PrismModel_fragment();
		EnterRule("synpred2_PrismModel_fragment", 58);
		TraceIn("synpred2_PrismModel_fragment", 58);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:156:18: ( modules )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:156:18: modules
			{
			DebugLocation(156, 18);
			PushFollow(Follow._modules_in_synpred2_PrismModel1039);
			modules();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_PrismModel_fragment", 58);
			LeaveRule("synpred2_PrismModel_fragment", 58);
			LeaveRule_synpred2_PrismModel_fragment();
		}
	}
	// $ANTLR end synpred2_PrismModel

	partial void EnterRule_synpred36_PrismModel_fragment();
	partial void LeaveRule_synpred36_PrismModel_fragment();

	// $ANTLR start synpred36_PrismModel
	public void synpred36_PrismModel_fragment()
	{
		IToken structName = default(IToken);

		EnterRule_synpred36_PrismModel_fragment();
		EnterRule("synpred36_PrismModel_fragment", 92);
		TraceIn("synpred36_PrismModel_fragment", 92);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:328:13: ( DQUOTE structName= ID DQUOTE )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:328:13: DQUOTE structName= ID DQUOTE
			{
			DebugLocation(328, 13);
			Match(input,DQUOTE,Follow._DQUOTE_in_synpred36_PrismModel1829); if (state.failed) return;
			DebugLocation(328, 31);
			structName=(IToken)Match(input,ID,Follow._ID_in_synpred36_PrismModel1835); if (state.failed) return;
			DebugLocation(328, 62);
			Match(input,DQUOTE,Follow._DQUOTE_in_synpred36_PrismModel1838); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred36_PrismModel_fragment", 92);
			LeaveRule("synpred36_PrismModel_fragment", 92);
			LeaveRule_synpred36_PrismModel_fragment();
		}
	}
	// $ANTLR end synpred36_PrismModel

	partial void EnterRule_synpred43_PrismModel_fragment();
	partial void LeaveRule_synpred43_PrismModel_fragment();

	// $ANTLR start synpred43_PrismModel
	public void synpred43_PrismModel_fragment()
	{
		Expression opr2 = default(Expression);

		EnterRule_synpred43_PrismModel_fragment();
		EnterRule("synpred43_PrismModel_fragment", 99);
		TraceIn("synpred43_PrismModel_fragment", 99);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:353:3: ( ( U | W | R ) ( timeBound )? opr2= expressionTemporalUnary )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:353:3: ( U | W | R ) ( timeBound )? opr2= expressionTemporalUnary
			{
			DebugLocation(353, 3);
			if (input.LA(1)==R||(input.LA(1)>=U && input.LA(1)<=W))
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(357, 3);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:357:3: ( timeBound )?
			int alt76=2;
			try { DebugEnterSubRule(76);
			try { DebugEnterDecision(76, false);
			int LA76_0 = input.LA(1);

			if ((LA76_0==GE||LA76_0==GT||(LA76_0>=LBRACKET && LA76_0<=LE)||LA76_0==LT))
			{
				alt76 = 1;
			}
			} finally { DebugExitDecision(76); }
			switch (alt76)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:357:4: timeBound
				{
				DebugLocation(357, 4);
				PushFollow(Follow._timeBound_in_synpred43_PrismModel1985);
				timeBound();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(76); }

			DebugLocation(358, 8);
			PushFollow(Follow._expressionTemporalUnary_in_synpred43_PrismModel1996);
			opr2=expressionTemporalUnary();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred43_PrismModel_fragment", 99);
			LeaveRule("synpred43_PrismModel_fragment", 99);
			LeaveRule_synpred43_PrismModel_fragment();
		}
	}
	// $ANTLR end synpred43_PrismModel

	partial void EnterRule_synpred48_PrismModel_fragment();
	partial void LeaveRule_synpred48_PrismModel_fragment();

	// $ANTLR start synpred48_PrismModel
	public void synpred48_PrismModel_fragment()
	{
		IToken var1 = default(IToken);

		EnterRule_synpred48_PrismModel_fragment();
		EnterRule("synpred48_PrismModel_fragment", 104);
		TraceIn("synpred48_PrismModel_fragment", 104);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:383:8: (var1= ID )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:383:8: var1= ID
			{
			DebugLocation(383, 13);
			var1=(IToken)Match(input,ID,Follow._ID_in_synpred48_PrismModel2089); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred48_PrismModel_fragment", 104);
			LeaveRule("synpred48_PrismModel_fragment", 104);
			LeaveRule_synpred48_PrismModel_fragment();
		}
	}
	// $ANTLR end synpred48_PrismModel

	partial void EnterRule_synpred50_PrismModel_fragment();
	partial void LeaveRule_synpred50_PrismModel_fragment();

	// $ANTLR start synpred50_PrismModel
	public void synpred50_PrismModel_fragment()
	{
		IToken var2 = default(IToken);

		EnterRule_synpred50_PrismModel_fragment();
		EnterRule("synpred50_PrismModel_fragment", 106);
		TraceIn("synpred50_PrismModel_fragment", 106);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:384:35: (var2= ID )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:384:35: var2= ID
			{
			DebugLocation(384, 40);
			var2=(IToken)Match(input,ID,Follow._ID_in_synpred50_PrismModel2114); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred50_PrismModel_fragment", 106);
			LeaveRule("synpred50_PrismModel_fragment", 106);
			LeaveRule_synpred50_PrismModel_fragment();
		}
	}
	// $ANTLR end synpred50_PrismModel

	partial void EnterRule_synpred52_PrismModel_fragment();
	partial void LeaveRule_synpred52_PrismModel_fragment();

	// $ANTLR start synpred52_PrismModel
	public void synpred52_PrismModel_fragment()
	{
		IToken var3 = default(IToken);

		EnterRule_synpred52_PrismModel_fragment();
		EnterRule("synpred52_PrismModel_fragment", 108);
		TraceIn("synpred52_PrismModel_fragment", 108);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:385:8: (var3= ID )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:385:8: var3= ID
			{
			DebugLocation(385, 13);
			var3=(IToken)Match(input,ID,Follow._ID_in_synpred52_PrismModel2137); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred52_PrismModel_fragment", 108);
			LeaveRule("synpred52_PrismModel_fragment", 108);
			LeaveRule_synpred52_PrismModel_fragment();
		}
	}
	// $ANTLR end synpred52_PrismModel

	partial void EnterRule_synpred54_PrismModel_fragment();
	partial void LeaveRule_synpred54_PrismModel_fragment();

	// $ANTLR start synpred54_PrismModel
	public void synpred54_PrismModel_fragment()
	{
		IToken var4 = default(IToken);

		EnterRule_synpred54_PrismModel_fragment();
		EnterRule("synpred54_PrismModel_fragment", 110);
		TraceIn("synpred54_PrismModel_fragment", 110);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:386:35: (var4= ID )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:386:35: var4= ID
			{
			DebugLocation(386, 40);
			var4=(IToken)Match(input,ID,Follow._ID_in_synpred54_PrismModel2162); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred54_PrismModel_fragment", 110);
			LeaveRule("synpred54_PrismModel_fragment", 110);
			LeaveRule_synpred54_PrismModel_fragment();
		}
	}
	// $ANTLR end synpred54_PrismModel

	partial void EnterRule_synpred63_PrismModel_fragment();
	partial void LeaveRule_synpred63_PrismModel_fragment();

	// $ANTLR start synpred63_PrismModel
	public void synpred63_PrismModel_fragment()
	{
		Expression timediv2 = default(Expression);

		EnterRule_synpred63_PrismModel_fragment();
		EnterRule("synpred63_PrismModel_fragment", 119);
		TraceIn("synpred63_PrismModel_fragment", 119);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:454:3: ( ( PLUS | MINUS ) timediv2= expressionTimesDivide )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:454:3: ( PLUS | MINUS ) timediv2= expressionTimesDivide
			{
			DebugLocation(454, 3);
			if (input.LA(1)==MINUS||input.LA(1)==PLUS)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(455, 12);
			PushFollow(Follow._expressionTimesDivide_in_synpred63_PrismModel2505);
			timediv2=expressionTimesDivide();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred63_PrismModel_fragment", 119);
			LeaveRule("synpred63_PrismModel_fragment", 119);
			LeaveRule_synpred63_PrismModel_fragment();
		}
	}
	// $ANTLR end synpred63_PrismModel

	partial void EnterRule_synpred84_PrismModel_fragment();
	partial void LeaveRule_synpred84_PrismModel_fragment();

	// $ANTLR start synpred84_PrismModel
	public void synpred84_PrismModel_fragment()
	{
		EnterRule_synpred84_PrismModel_fragment();
		EnterRule("synpred84_PrismModel_fragment", 140);
		TraceIn("synpred84_PrismModel_fragment", 140);
		try
		{
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:556:4: ( LPARENTH expressionFuncArgs[argsOfFunc] RPARENTH )
			DebugEnterAlt(1);
			// D:\\Development\\PAT\\PAT 3.5\\PAT.Common\\Classes\\SemanticModels\\Prob\\PrismParser\\PrismModel.g:556:4: LPARENTH expressionFuncArgs[argsOfFunc] RPARENTH
			{
			DebugLocation(556, 4);
			Match(input,LPARENTH,Follow._LPARENTH_in_synpred84_PrismModel2922); if (state.failed) return;
			DebugLocation(556, 13);
			PushFollow(Follow._expressionFuncArgs_in_synpred84_PrismModel2924);
			expressionFuncArgs(argsOfFunc);
			PopFollow();
			if (state.failed) return;
			DebugLocation(556, 82);
			Match(input,RPARENTH,Follow._RPARENTH_in_synpred84_PrismModel2928); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred84_PrismModel_fragment", 140);
			LeaveRule("synpred84_PrismModel_fragment", 140);
			LeaveRule_synpred84_PrismModel_fragment();
		}
	}
	// $ANTLR end synpred84_PrismModel
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA42 dfa42;
	private DFA50 dfa50;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa42 = new DFA42( this, SpecialStateTransition42 );
		dfa50 = new DFA50( this, SpecialStateTransition50 );
	}

	private class DFA42 : DFA
	{
		private const string DFA42_eotS =
			"\x3D\xFFFF";
		private const string DFA42_eofS =
			"\x1\x1\x3C\xFFFF";
		private const string DFA42_minS =
			"\x1\x4\xD\xFFFF\x1\x0\x2E\xFFFF";
		private const string DFA42_maxS =
			"\x1\x58\xD\xFFFF\x1\x0\x2E\xFFFF";
		private const string DFA42_acceptS =
			"\x1\xFFFF\x1\x2\x3A\xFFFF\x1\x1";
		private const string DFA42_specialS =
			"\xE\xFFFF\x1\x0\x2E\xFFFF}>";
		private static readonly string[] DFA42_transitionS =
			{
				"\x2\x1\x3\xFFFF\x2\x1\x1\xFFFF\x2\x1\x2\xFFFF\x1\x1\x1\xFFFF\x4\x1\x4"+
				"\xFFFF\xA\x1\x1\xFFFF\x1\x1\x1\xFFFF\x2\x1\x1\xFFFF\x1\x1\x1\xFFFF\x4"+
				"\x1\x1\xFFFF\x5\x1\x1\xE\x6\x1\x1\x3C\x2\x1\x1\xFFFF\x2\x1\x1\xFFFF"+
				"\x6\x1\x1\xFFFF\x7\x1\x2\xFFFF\x3\x1\x1\xFFFF\x1\x1",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA42_eot = DFA.UnpackEncodedString(DFA42_eotS);
		private static readonly short[] DFA42_eof = DFA.UnpackEncodedString(DFA42_eofS);
		private static readonly char[] DFA42_min = DFA.UnpackEncodedStringToUnsignedChars(DFA42_minS);
		private static readonly char[] DFA42_max = DFA.UnpackEncodedStringToUnsignedChars(DFA42_maxS);
		private static readonly short[] DFA42_accept = DFA.UnpackEncodedString(DFA42_acceptS);
		private static readonly short[] DFA42_special = DFA.UnpackEncodedString(DFA42_specialS);
		private static readonly short[][] DFA42_transition;

		static DFA42()
		{
			int numStates = DFA42_transitionS.Length;
			DFA42_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA42_transition[i] = DFA.UnpackEncodedString(DFA42_transitionS[i]);
			}
		}

		public DFA42( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 42;
			this.eot = DFA42_eot;
			this.eof = DFA42_eof;
			this.min = DFA42_min;
			this.max = DFA42_max;
			this.accept = DFA42_accept;
			this.special = DFA42_special;
			this.transition = DFA42_transition;
		}

		public override string Description { get { return "()* loopback of 453:2: ( ( PLUS | MINUS ) timediv2= expressionTimesDivide )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition42(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA42_14 = input.LA(1);


				int index42_14 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred63_PrismModel_fragment))) {s = 60;}

				else if ((true)) {s = 1;}


				input.Seek(index42_14);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 42, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA50 : DFA
	{
		private const string DFA50_eotS =
			"\x40\xFFFF";
		private const string DFA50_eofS =
			"\x1\x2\x3F\xFFFF";
		private const string DFA50_minS =
			"\x1\x4\x1\x0\x3E\xFFFF";
		private const string DFA50_maxS =
			"\x1\x58\x1\x0\x3E\xFFFF";
		private const string DFA50_acceptS =
			"\x2\xFFFF\x1\x2\x3C\xFFFF\x1\x1";
		private const string DFA50_specialS =
			"\x1\xFFFF\x1\x0\x3E\xFFFF}>";
		private static readonly string[] DFA50_transitionS =
			{
				"\x2\x2\x3\xFFFF\x2\x2\x1\xFFFF\x3\x2\x1\xFFFF\x1\x2\x1\xFFFF\x4\x2\x4"+
				"\xFFFF\xA\x2\x1\xFFFF\x1\x2\x1\xFFFF\x2\x2\x1\xFFFF\x1\x2\x1\xFFFF\x4"+
				"\x2\x1\xFFFF\x1\x1\xE\x2\x1\xFFFF\x2\x2\x1\xFFFF\x6\x2\x1\xFFFF\x7\x2"+
				"\x1\xFFFF\x4\x2\x1\xFFFF\x1\x2",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA50_eot = DFA.UnpackEncodedString(DFA50_eotS);
		private static readonly short[] DFA50_eof = DFA.UnpackEncodedString(DFA50_eofS);
		private static readonly char[] DFA50_min = DFA.UnpackEncodedStringToUnsignedChars(DFA50_minS);
		private static readonly char[] DFA50_max = DFA.UnpackEncodedStringToUnsignedChars(DFA50_maxS);
		private static readonly short[] DFA50_accept = DFA.UnpackEncodedString(DFA50_acceptS);
		private static readonly short[] DFA50_special = DFA.UnpackEncodedString(DFA50_specialS);
		private static readonly short[][] DFA50_transition;

		static DFA50()
		{
			int numStates = DFA50_transitionS.Length;
			DFA50_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA50_transition[i] = DFA.UnpackEncodedString(DFA50_transitionS[i]);
			}
		}

		public DFA50( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 50;
			this.eot = DFA50_eot;
			this.eof = DFA50_eof;
			this.min = DFA50_min;
			this.max = DFA50_max;
			this.accept = DFA50_accept;
			this.special = DFA50_special;
			this.transition = DFA50_transition;
		}

		public override string Description { get { return "556:2: ( LPARENTH expressionFuncArgs[argsOfFunc] RPARENTH )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition50(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA50_1 = input.LA(1);


				int index50_1 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred84_PrismModel_fragment))) {s = 63;}

				else if ((true)) {s = 2;}


				input.Seek(index50_1);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 50, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _properties_in_prismmodel1035 = new BitSet(new ulong[]{0xD6FA1524F01C3012UL,0x12B8A6UL});
		public static readonly BitSet _modules_in_prismmodel1039 = new BitSet(new ulong[]{0xD6FA1524F01C3012UL,0x12B8A6UL});
		public static readonly BitSet _property_in_properties1056 = new BitSet(new ulong[]{0x2UL,0x10000UL});
		public static readonly BitSet _SEMICOLON_in_properties1059 = new BitSet(new ulong[]{0x2UL,0x10000UL});
		public static readonly BitSet _labelDef_in_properties1068 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constantDef_in_properties1074 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DQUOTE_in_property1096 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_property1098 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _DQUOTE_in_property1101 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _COLON_in_property1103 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionITE_in_property1112 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _moduleType_in_modules1133 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _globalDecl_in_modules1139 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _formulaDef_in_modules1145 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _labelDef_in_modules1151 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constantDef_in_modules1157 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _renamedModule_in_modules1163 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _module_in_modules1169 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewardStruct_in_modules1175 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _initExp_in_modules1181 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_moduleType1206 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_moduleType1220 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_moduleType1234 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GLOBAL_in_globalDecl1261 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _declaration_in_globalDecl1263 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_declaration1283 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _COLON_in_declaration1285 = new BitSet(new ulong[]{0x400000000040UL});
		public static readonly BitSet _varType_in_declaration1287 = new BitSet(new ulong[]{0x10000000000UL,0x10000UL});
		public static readonly BitSet _INIT_in_declaration1291 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_declaration1297 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _SEMICOLON_in_declaration1302 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACKET_in_varType1321 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_varType1327 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _DOTS_in_varType1329 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_varType1335 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RBRACKET_in_varType1337 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BOOL_in_varType1344 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FORMULA_in_formulaDef1362 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_formulaDef1364 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_formulaDef1366 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_formulaDef1372 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _SEMICOLON_in_formulaDef1374 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LABEL_in_labelDef1391 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _DQUOTE_in_labelDef1393 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_labelDef1395 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _DQUOTE_in_labelDef1397 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_labelDef1399 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_labelDef1405 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _SEMICOLON_in_labelDef1407 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONST_in_constantDef1426 = new BitSet(new ulong[]{0x22000020040UL});
		public static readonly BitSet _INT_in_constantDef1429 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _DOUBLE_in_constantDef1434 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _BOOL_in_constantDef1439 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _set_in_constantDef1448 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_constantDef1459 = new BitSet(new ulong[]{0x4000000UL,0x10000UL});
		public static readonly BitSet _EQ_in_constantDef1464 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_constantDef1466 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _SEMICOLON_in_constantDef1471 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MODULE_in_module1493 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_module1499 = new BitSet(new ulong[]{0x402000800000UL});
		public static readonly BitSet _declaration_in_module1509 = new BitSet(new ulong[]{0x402000800000UL});
		public static readonly BitSet _command_in_module1520 = new BitSet(new ulong[]{0x400000800000UL});
		public static readonly BitSet _ENDMODULE_in_module1526 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACKET_in_command1545 = new BitSet(new ulong[]{0x2000000000UL,0x200UL});
		public static readonly BitSet _ID_in_command1549 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RBRACKET_in_command1556 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_command1559 = new BitSet(new ulong[]{0x0UL,0x40UL});
		public static readonly BitSet _RARROW_in_command1562 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _updates_in_command1564 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _SEMICOLON_in_command1568 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignments_in_updates1592 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_updates1602 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _COLON_in_updates1604 = new BitSet(new ulong[]{0x2000000000000UL,0x100000UL});
		public static readonly BitSet _assignments_in_updates1610 = new BitSet(new ulong[]{0x2000000000000002UL});
		public static readonly BitSet _PLUS_in_updates1615 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_updates1621 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _COLON_in_updates1623 = new BitSet(new ulong[]{0x2000000000000UL,0x100000UL});
		public static readonly BitSet _assignments_in_updates1629 = new BitSet(new ulong[]{0x2000000000000002UL});
		public static readonly BitSet _assignment_in_assignments1656 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _AND_in_assignments1661 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _assignment_in_assignments1667 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _TRUE_in_assignments1676 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPARENTH_in_assignment1695 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _idPrime_in_assignment1697 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_assignment1699 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_assignment1701 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPARENTH_in_assignment1703 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_idPrime1723 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _PRIME_in_idPrime1725 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MODULE_in_renamedModule1745 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_renamedModule1751 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_renamedModule1753 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_renamedModule1759 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _LBRACKET_in_renamedModule1762 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _rename_in_renamedModule1764 = new BitSet(new ulong[]{0x400UL,0x200UL});
		public static readonly BitSet _COMMA_in_renamedModule1768 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _rename_in_renamedModule1770 = new BitSet(new ulong[]{0x400UL,0x200UL});
		public static readonly BitSet _RBRACKET_in_renamedModule1775 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _ENDMODULE_in_renamedModule1777 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_rename1798 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_rename1800 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_rename1806 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REWARDS_in_rewardStruct1826 = new BitSet(new ulong[]{0xD46A4421B9140010UL,0x110B020UL});
		public static readonly BitSet _DQUOTE_in_rewardStruct1829 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_rewardStruct1835 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _DQUOTE_in_rewardStruct1838 = new BitSet(new ulong[]{0xD46A4421B9140010UL,0x110B020UL});
		public static readonly BitSet _LBRACKET_in_rewardStruct1845 = new BitSet(new ulong[]{0x2000000000UL,0x200UL});
		public static readonly BitSet _ID_in_rewardStruct1853 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RBRACKET_in_rewardStruct1858 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_rewardStruct1867 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _COLON_in_rewardStruct1869 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_rewardStruct1875 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _SEMICOLON_in_rewardStruct1877 = new BitSet(new ulong[]{0xD46A4421B9140010UL,0x110B020UL});
		public static readonly BitSet _ENDREWARDS_in_rewardStruct1882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INIT_in_initExp1904 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_initExp1906 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ENDINIT_in_initExp1909 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionTemporalBinary_in_expression1927 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionTemporalUnary_in_expressionTemporalBinary1951 = new BitSet(new ulong[]{0x2UL,0x600020UL});
		public static readonly BitSet _U_in_expressionTemporalBinary1961 = new BitSet(new ulong[]{0xD46EC42BB8140010UL,0x110B020UL});
		public static readonly BitSet _W_in_expressionTemporalBinary1968 = new BitSet(new ulong[]{0xD46EC42BB8140010UL,0x110B020UL});
		public static readonly BitSet _R_in_expressionTemporalBinary1975 = new BitSet(new ulong[]{0xD46EC42BB8140010UL,0x110B020UL});
		public static readonly BitSet _timeBound_in_expressionTemporalBinary1985 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expressionTemporalUnary_in_expressionTemporalBinary1996 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _X_in_expressionTemporalUnary2024 = new BitSet(new ulong[]{0xD46EC42BB8140010UL,0x110B020UL});
		public static readonly BitSet _F_in_expressionTemporalUnary2030 = new BitSet(new ulong[]{0xD46EC42BB8140010UL,0x110B020UL});
		public static readonly BitSet _G_in_expressionTemporalUnary2036 = new BitSet(new ulong[]{0xD46EC42BB8140010UL,0x110B020UL});
		public static readonly BitSet _timeBound_in_expressionTemporalUnary2044 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expressionTemporalUnary_in_expressionTemporalUnary2054 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionITE_in_expressionTemporalUnary2059 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LE_in_timeBound2082 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _ID_in_timeBound2089 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_timeBound2098 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_timeBound2105 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _ID_in_timeBound2114 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_timeBound2123 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GE_in_timeBound2130 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _ID_in_timeBound2137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_timeBound2146 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GT_in_timeBound2153 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _ID_in_timeBound2162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_timeBound2171 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACKET_in_timeBound2178 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_timeBound2184 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _COMMA_in_timeBound2187 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_timeBound2193 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RBRACKET_in_timeBound2196 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionImplies_in_expressionITE2222 = new BitSet(new ulong[]{0x2UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionITE2227 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionImplies_in_expressionITE2233 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _COLON_in_expressionITE2235 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionITE_in_expressionITE2241 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionIff_in_expressionImplies2270 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _IMPLIES_in_expressionImplies2275 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionIff_in_expressionImplies2281 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _expressionOr_in_expressionIff2305 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionAnd_in_expressionOr2331 = new BitSet(new ulong[]{0x800000000000002UL});
		public static readonly BitSet _OR_in_expressionOr2335 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionAnd_in_expressionOr2341 = new BitSet(new ulong[]{0x800000000000002UL});
		public static readonly BitSet _expressionEquality_in_expressionAnd2367 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _AND_in_expressionAnd2371 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionEquality_in_expressionAnd2377 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _expressionRelop_in_expressionEquality2403 = new BitSet(new ulong[]{0x100000004000002UL});
		public static readonly BitSet _eqNeq_in_expressionEquality2409 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionRelop_in_expressionEquality2415 = new BitSet(new ulong[]{0x100000004000002UL});
		public static readonly BitSet _expressionPlusMinus_in_expressionRelop2441 = new BitSet(new ulong[]{0x4800A00000002UL});
		public static readonly BitSet _ltGt_in_expressionRelop2447 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionPlusMinus_in_expressionRelop2453 = new BitSet(new ulong[]{0x4800A00000002UL});
		public static readonly BitSet _expressionTimesDivide_in_expressionPlusMinus2479 = new BitSet(new ulong[]{0x2040000000000002UL});
		public static readonly BitSet _PLUS_in_expressionPlusMinus2489 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _MINUS_in_expressionPlusMinus2494 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionTimesDivide_in_expressionPlusMinus2505 = new BitSet(new ulong[]{0x2040000000000002UL});
		public static readonly BitSet _expressionUnaryMinus_in_expressionTimesDivide2533 = new BitSet(new ulong[]{0x4002UL,0x80000UL});
		public static readonly BitSet _TIMES_in_expressionTimesDivide2543 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _DIVIDE_in_expressionTimesDivide2548 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionUnaryMinus_in_expressionTimesDivide2559 = new BitSet(new ulong[]{0x4002UL,0x80000UL});
		public static readonly BitSet _MINUS_in_expressionUnaryMinus2583 = new BitSet(new ulong[]{0xD02A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionBasic_in_expressionUnaryMinus2589 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_expressionUnaryMinus2595 = new BitSet(new ulong[]{0xD02A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionBasic_in_expressionUnaryMinus2601 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionBasic_in_expressionUnaryMinus2611 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionLiteral_in_expressionBasic2631 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionFuncMinMax_in_expressionBasic2637 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionParenth_in_expressionBasic2643 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionFuncOrIdent_in_expressionBasic2649 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionFuncOldStyle_in_expressionBasic2655 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionProb_in_expressionBasic2663 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionSS_in_expressionBasic2669 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionReward_in_expressionBasic2675 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionExists_in_expressionBasic2681 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionForAll_in_expressionBasic2687 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionLabel_in_expressionBasic2693 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionFilter_in_expressionBasic2699 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _intNumber_in_expressionLiteral2719 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _doubleNumber_in_expressionLiteral2725 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_expressionLiteral2731 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_expressionLiteral2738 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_NUM_in_intNumber2760 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_NUM_in_doubleNumber2786 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _DOT_in_doubleNumber2790 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _INT_NUM_in_doubleNumber2796 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MIN_in_expressionFuncMinMax2820 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _MAX_in_expressionFuncMinMax2825 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _LPARENTH_in_expressionFuncMinMax2830 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expressionFuncArgs_in_expressionFuncMinMax2833 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPARENTH_in_expressionFuncMinMax2836 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressionFuncArgs2858 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _COMMA_in_expressionFuncArgs2862 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionFuncArgs2868 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _LPARENTH_in_expressionParenth2890 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionParenth2892 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPARENTH_in_expressionParenth2895 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expressionFuncOrIdent2914 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _LPARENTH_in_expressionFuncOrIdent2922 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expressionFuncArgs_in_expressionFuncOrIdent2924 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPARENTH_in_expressionFuncOrIdent2928 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNC_in_expressionFuncOldStyle2949 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _LPARENTH_in_expressionFuncOldStyle2951 = new BitSet(new ulong[]{0x28002000000000UL});
		public static readonly BitSet _MIN_in_expressionFuncOldStyle2955 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _MAX_in_expressionFuncOldStyle2961 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ID_in_expressionFuncOldStyle2967 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _COMMA_in_expressionFuncOldStyle2973 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expressionFuncArgs_in_expressionFuncOldStyle2975 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPARENTH_in_expressionFuncOldStyle2978 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQ_in_eqNeq2999 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NE_in_eqNeq3005 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GT_in_ltGt3024 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_ltGt3030 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GE_in_ltGt3036 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LE_in_ltGt3042 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _P_in_expressionProb3064 = new BitSet(new ulong[]{0x2C800A04000000UL});
		public static readonly BitSet _ltGt_in_expressionProb3069 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionProb3075 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _EQ_in_expressionProb3081 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionProb3083 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _MIN_in_expressionProb3089 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_expressionProb3091 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionProb3093 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _MAX_in_expressionProb3099 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_expressionProb3101 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionProb3103 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _PMIN_in_expressionProb3112 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_expressionProb3114 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionProb3116 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _PMAX_in_expressionProb3122 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_expressionProb3124 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionProb3126 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _LBRACKET_in_expressionProb3133 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionProb3139 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _filter_in_expressionProb3142 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RBRACKET_in_expressionProb3148 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_filter3168 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_filter3174 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _RBRACE_in_filter3177 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _LBRACE_in_filter3181 = new BitSet(new ulong[]{0x28000000000000UL});
		public static readonly BitSet _MIN_in_filter3187 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _MAX_in_filter3193 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _RBRACE_in_filter3201 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _S_in_expressionSS3222 = new BitSet(new ulong[]{0x4800A04000000UL});
		public static readonly BitSet _ltGt_in_expressionSS3230 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionSS3236 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _EQ_in_expressionSS3241 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionSS3243 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _LBRACKET_in_expressionSS3252 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionSS3258 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _filter_in_expressionSS3261 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RBRACKET_in_expressionSS3267 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _R_in_expressionReward3287 = new BitSet(new ulong[]{0x2CA00A04000000UL});
		public static readonly BitSet _rewardIndex_in_expressionReward3290 = new BitSet(new ulong[]{0x2C800A04000000UL});
		public static readonly BitSet _ltGt_in_expressionReward3297 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionReward3303 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _EQ_in_expressionReward3309 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionReward3311 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _MIN_in_expressionReward3317 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_expressionReward3319 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionReward3321 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _MAX_in_expressionReward3327 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_expressionReward3329 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionReward3331 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _RMIN_in_expressionReward3340 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_expressionReward3342 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionReward3344 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _RMAX_in_expressionReward3350 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_expressionReward3352 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _QMARK_in_expressionReward3354 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _LBRACKET_in_expressionReward3361 = new BitSet(new ulong[]{0x1008000080UL,0x8000UL});
		public static readonly BitSet _expressionRewardContents_in_expressionReward3367 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _filter_in_expressionReward3370 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RBRACKET_in_expressionReward3376 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_rewardIndex3394 = new BitSet(new ulong[]{0x40000040000UL});
		public static readonly BitSet _DQUOTE_in_rewardIndex3398 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_rewardIndex3400 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _DQUOTE_in_rewardIndex3403 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _INT_NUM_in_rewardIndex3408 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _RBRACE_in_rewardIndex3415 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _C_in_expressionRewardContents3438 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _LE_in_expressionRewardContents3440 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionRewardContents3446 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _I_in_expressionRewardContents3452 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _EQ_in_expressionRewardContents3454 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionRewardContents3460 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _F_in_expressionRewardContents3466 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionRewardContents3472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _S_in_expressionRewardContents3478 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _E_in_expressionExists3508 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _LBRACKET_in_expressionExists3510 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionExists3516 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RBRACKET_in_expressionExists3518 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _A_in_expressionForAll3542 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _LBRACKET_in_expressionForAll3544 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionForAll3550 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RBRACKET_in_expressionForAll3552 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DQUOTE_in_expressionLabel3576 = new BitSet(new ulong[]{0x12000000000UL});
		public static readonly BitSet _ID_in_expressionLabel3579 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _INIT_in_expressionLabel3584 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _DQUOTE_in_expressionLabel3589 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FILTER_in_expressionFilter3613 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _LPARENTH_in_expressionFilter3615 = new BitSet(new ulong[]{0x2828002000000020UL});
		public static readonly BitSet _MIN_in_expressionFilter3620 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _MAX_in_expressionFilter3628 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _PLUS_in_expressionFilter3635 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _AND_in_expressionFilter3642 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _OR_in_expressionFilter3649 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ID_in_expressionFilter3656 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _COMMA_in_expressionFilter3664 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionFilter3670 = new BitSet(new ulong[]{0x400UL,0x4000UL});
		public static readonly BitSet _COMMA_in_expressionFilter3674 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expression_in_expressionFilter3680 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPARENTH_in_expressionFilter3686 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _properties_in_synpred1_PrismModel1035 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modules_in_synpred2_PrismModel1039 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DQUOTE_in_synpred36_PrismModel1829 = new BitSet(new ulong[]{0x2000000000UL});
		public static readonly BitSet _ID_in_synpred36_PrismModel1835 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _DQUOTE_in_synpred36_PrismModel1838 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_synpred43_PrismModel1959 = new BitSet(new ulong[]{0xD46EC42BB8140010UL,0x110B020UL});
		public static readonly BitSet _timeBound_in_synpred43_PrismModel1985 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expressionTemporalUnary_in_synpred43_PrismModel1996 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred48_PrismModel2089 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred50_PrismModel2114 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred52_PrismModel2137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred54_PrismModel2162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_synpred63_PrismModel2488 = new BitSet(new ulong[]{0xD46A0420B0140010UL,0x10B020UL});
		public static readonly BitSet _expressionTimesDivide_in_synpred63_PrismModel2505 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPARENTH_in_synpred84_PrismModel2922 = new BitSet(new ulong[]{0xD46A0421B8140010UL,0x110B020UL});
		public static readonly BitSet _expressionFuncArgs_in_synpred84_PrismModel2924 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPARENTH_in_synpred84_PrismModel2928 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
